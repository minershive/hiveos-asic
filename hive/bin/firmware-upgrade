#!/bin/sh -e


#
# Copyright (C) 2016-2020  Hiveon
# Distributed under GNU GENERAL PUBLIC LICENSE 2.0
# License information can be found in the LICENSE file or at https://github.com/minershive/hiveos-asic/blob/master/LICENSE.txt
#


readonly script_mission='Client for ASICs: Antminer Firmware Upgrade'
readonly script_version='0.1.9'
readonly script_basename="$( basename "$0" )"


# !!! sh -e


# functions

print_script_version () {
	echo -e "${YELLOW}${script_mission}, version ${script_version}${NOCOLOR}"
	echo
}

print_script_usage () {
	echo -e "  Usage: ${CYAN}${script_basename} firmware-package-URL${NOCOLOR}"
	echo
	echo '  Firmware package, stock ot custom, must be in .tar.gz format'
	echo
}

hide_certs () {
	# hide upgrade scripts, version file and certificates
	echo '> Disabling cert protection...'
	for this_file in /www/pages/cgi-bin/upgrade.cgi /www/pages/cgi-bin/upgrade2.cgi /www/pages/cgi-bin/upgrade_clear.cgi \
					/etc/ant_version /etc/bitmain-pub.pem /etc/msk-pub.pem; do
		if [ -f "$this_file" ]; then
			mv -f "$this_file" "${this_file}-disabled" || true
		fi
	done
	is_certs_hidden=1
}

unhide_certs () {
	# unhide upgrade scripts, version file and certificates
	if [ "$is_certs_hidden" -eq 1 ]; then
		echo '> Enabling cert protection...'
		for this_file in /etc/ant_version /etc/bitmain-pub.pem /etc/msk-pub.pem \
						 /www/pages/cgi-bin/upgrade.cgi /www/pages/cgi-bin/upgrade2.cgi \
						 /www/pages/cgi-bin/upgrade_clear.cgi; do					
			if [ -f "${this_file}-disabled" ]; then
				mv -f "${this_file}-disabled" "$this_file" || true
			fi
		done
		is_certs_hidden=0
	fi
}

at_exit () {
	echo '> Exiting...'
	rm -rf "${directory_to_unpack_fw:-/tmp/*}" || true
	umount "$directory_to_unpack_fw.boot" 2>/dev/null || true
	rmdir "$directory_to_unpack_fw.boot" 2>/dev/null || true
	unhide_certs
	sync
	if [ -z "$ok" ]; then
		echo -e "${RED}Firmware upgrade unexpectedly interrupted${NOCOLOR}"
		if [ -s /tmp/upgrade_result ]; then
			echo '> runme.sh log:'
			cat /tmp/upgrade_result
		fi
	fi
}

do_upgrade_for () {

	# args

	local upgrade_type="$1"

	# code

	echo -e "> Upgrading firmware for $ASIC_MODEL..."

	# check for .tar.gz extension
	firmware_filename="$( echo "$URL" | awk -F \/ '{print $NF}' )"
	if ! { echo "$firmware_filename" | grep -q '.tar.gz'; }; then
		echo -e "${BYELLOW}Firmware's filename does not contain '.tar.gz', trying anyway...${NOCOLOR}"
	fi

	# get FARM_HASH from a firmware's filename
	FARM_HASH="$( echo "$firmware_filename" | awk -F \- '{print $NF}' | sed s/.tar.gz// )"

	# get HIVE_HOST_URL from a firmware's filename
	HIVE_HOST_URL="$( echo "$URL" | grep 'http://download' | grep 'os' | grep '/asic/' | awk -F \/asic '{print $1}' | sed s/'http:\/\/download'/'http:\/\/api'/ )"

	# remove huge temp files (1M and up)
	for this_huge_file in $( du -h /tmp/* /var/log/* | awk '/^[0-9.]+M/{print $2}' ); do
		echo "> Clearing the space, removing $this_huge_file (it's greater than 1M)..."
		rm "$this_huge_file" || true
	done

	# create a temp dir
	directory_to_unpack_fw="/tmp/$$"
	mkdir "$directory_to_unpack_fw"
	cd "$directory_to_unpack_fw"
	trap at_exit EXIT

	# drop caches
	sync && echo 3 > /proc/sys/vm/drop_caches

	# liftoff!
	"upgrade_$upgrade_type"
}

upgrade_L3 () {
	echo "> Downloading and unpacking $firmware_filename..."
	curl --silent --fail --insecure "$URL" | tar xvz
	if [ -f runme.sh ]; then
		echo '> Executing runme.sh...'
		sh runme.sh
		echo '> runme.sh finished'
	else
		if [ -e /dev/mmcblk0p3 ]; then
			mkdir "$directory_to_unpack_fw.boot"
			mount /dev/mmcblk0p1 "$directory_to_unpack_fw.boot"
			cp -rf ./* "$directory_to_unpack_fw.boot/"
			umount "$directory_to_unpack_fw.boot"
			sync
		fi
		if [ -e /dev/mtd8 ]; then
			if [ -f initramfs.bin.SD ]; then
				echo '> Flashing romfs...'
				flash_eraseall /dev/mtd8 >/dev/null 2>&1
				nandwrite -p /dev/mtd8 initramfs.bin.SD >/dev/null 2>&1
			fi

			if [ -f uImage.bin ]; then
				echo '> Flashing kernel...'
				flash_eraseall /dev/mtd7 2>/dev/null
				nandwrite -p /dev/mtd7 uImage.bin 2>/dev/null
			fi
		fi
	fi

	ok=1
	echo
	echo '> Flashing done'

	sleep 1
	/sbin/reboot -f
}

upgrade_S9 () {
#	rm -rf /config/hive/hive
#	rm -rf /hive ## no longer needed after cleaning /tmp
	for this_directory in /tmp/*; do
		# remove all dirs in /tmp that are not links
		if [ -d "$this_directory" ] && [ ! -L "$this_directory" ] && [ "$this_directory" != "$directory_to_unpack_fw" ]; then
			rm -rf "$this_directory" || true
		fi
	done

	#exec 2>"$error_log"
	echo "> Downloading and unpacking $firmware_filename..."
	curl --silent --fail --insecure "$URL" | tar xvz
	if [ ! -f ubi_info ]; then
		echo -e "${RED}Incorrect firmware (no 'ubi_info' found)${NOCOLOR}"
		#rm -rf /tmp/* # don't have to do this bc we have at_exit destructor that'll take care of everything
		exit 1
	else
		if [ ! -d /mnt/config ]; then
			mkdir /mnt/config
		fi
		ubiattach /dev/ubi_ctrl -m 2
		mount -t ubifs ubi1:rootfs /mnt/config
		if [ ! -d /mnt/config/home/usr_config ]; then
			mkdir /mnt/config/home/usr_config
		fi

		sed -i '/\#\#\# HIVE HECK \#\#\#/,$d' /config/network.conf
		cat >> /config/network.conf <<-FILEEOF
			### HIVE HECK ###
			if [ ! -L /hive-config ] && [ ! -e /hive-config ] && [ -d /config/hive ]; then
			    ln -s /config/hive/hive-config /hive-config
			    case "\$PATH" in
			        *'/hive/bin:/hive/sbin'*)	: ok good to go								;;
			        *)							export PATH="\$PATH:/hive/bin:/hive/sbin"	;;
			    esac
			    export LD_LIBRARY_PATH=/hive/lib
			    cp -rf /hive/share/S9/S69hive /etc/rcS.d/
			    cp -rf /hive/share/S9/.profile /home/root/
			    /hive/bin/hive
			fi
		FILEEOF

		if [ "${#FARM_HASH}" -eq 40 ]; then
			echo "$FARM_HASH" > /config/FARM_HASH
		fi
		if [ -n "$HIVE_HOST_URL" ]; then
			echo "$HIVE_HOST_URL" > /config/HIVE_HOST_URL
		fi
		sync
		cp -r /config/* /mnt/config/home/usr_config/
		umount /mnt/config
		ubidetach -d 1 /dev/ubi_ctrl
		if [ -f runme.sh ]; then
			hide_certs
			echo '> Executing runme.sh...'
			sh runme.sh
			echo '> runme.sh finished'
			echo -e "${GREEN}Firmware upgrade complete. Rebooting...${NOCOLOR}"
		else
			echo -e "${RED}Incorrect firmware (no 'runme.sh' found)${NOCOLOR}"
			exit 1
		fi
	fi

	#cat "$error_log"
	ok=1
	sleep 1
	/sbin/reboot -f
}

upgrade_ro () {
	# models with read-only fs
	[ -e /nvdata/latest.tar.gz ] && { rm -rf /nvdata/latest.tar.gz > /dev/null 2>&1 || true; }

	exec 2>"$error_log" # redirect stderr to file

	# save FARM_HASH to the corresponding file
	if [ "${#FARM_HASH}" -eq 40 ]; then
		echo "$FARM_HASH" > /config/FARM_HASH
	fi

	# save HIVE_HOST_URL to the corresponding file
	if [ -n "$HIVE_HOST_URL" ]; then
		echo "$HIVE_HOST_URL" > /config/HIVE_HOST_URL
	fi

	sync

	echo "> Downloading and unpacking $firmware_filename..."
	curl --silent --fail --insecure "$URL" | tar xvz
	hide_certs
	echo '> Executing runme.sh...'
	sh runme.sh
	echo '> runme.sh finished'

	if [ ! -s "$error_log" ]; then
		echo "> Firmware upgrade done. Rebooting..."
		# TODO should we fork the reboot to bg? so the agent can send a message to server?
		sleep 10
		sh /www/pages/cgi-bin/reboot.cgi || { sleep 5; /sbin/reboot -f; }
	else
		cat "$error_log"
	fi

	ok=1
}


# consts

readonly error_log="/tmp/$script_basename.log"


# vars

is_certs_hidden=0


# sources

[ -f /hive/bin/colors ] && . colors


# main

export PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:/hive/bin:/hive/sbin
[ -f /usr/bin/compile_time ] && ASIC_MODEL="$( sed -n 2p /usr/bin/compile_time )" # Antminer model

print_script_version

case "$1" in
	''|'-h'|'--help')
		print_script_usage
		exit
	;;

	'http://'*|'https://'*)
		URL="$1"
	;;

	*)
		print_script_usage
		exit 1
	;;
esac

case "$ASIC_MODEL" in
	'Antminer S9'*		|\
	'Antminer S10'*)	do_upgrade_for 'S9'	;;

	'Antminer S9k'*		|\
	'Antminer S9SE'*	|\
	'Antminer S15'*		|\
	'Antminer S17'*		|\
	'Antminer T15'*		|\
	'Antminer T17'*		|\
	'Antminer X17'*)	do_upgrade_for 'ro'	;;

	'Antminer L3'*)		do_upgrade_for 'L3'	;;

	*)
		echo -e "${BRED}$ASIC_MODEL not supported, exiting...${NOCOLOR}"
		exit 1
	;;
esac

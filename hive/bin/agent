#!/hive/sbin/bash


#
# Copyright (C) 2017  Hiveon Holding LTD
# Distributed under Business Source License 1.1
# License information can be found in the LICENSE.txt file or at https://github.com/minershive/hiveos-asic/blob/master/LICENSE.txt
#


readonly script_mission='Client for ASICs: The Agent'
readonly script_version='0.14.3-debug'
readonly script_basename="${0##*/}"
#
readonly script_DEBUG="${script_DEBUG:-0}" # use value from env if exists


# !!! bash strict mode, no unbound variables
#set -o nounset # commented out for production bc still not tested thoroughly


# functions

function debug_print_variable {
	#
	# Usage: debug_print_variable 'variable_name'...
	#

	# consts
	local -r debug_prefix='|'

	# vars
	local this_var this_var_name this_var_status JSON_array_size variable_color
	local -i max_length=0 this_var_size total_vars_count total_vars_size

	# code
	for this_var in "$@"; do
		(( ${#this_var} > max_length )) && max_length="${#this_var}"
	done

	printf "${DGRAY}%s %-${max_length}.${max_length}s %8.8s %4.4s  %s %s${NOCOLOR}\n" "$debug_prefix" 'var' 'bytes' 'idx' 'value'

	for this_var_name in $( printf '%s\n' "$@" | sort ); do
		JSON_array_size=''
		variable_color="${NOCOLOR}"
		this_var_size=0
		local -n this_var_value="$this_var_name"

		if [[ ! "${this_var_value+is_set}" ]]; then
			this_var_status='unset'
		elif [[ -z "${this_var_value}" ]]; then
			this_var_status='empty'
		else
			this_var_size="${#this_var_value}"
			this_var_status="${this_var_size}"
			if JSON_array_size="$( jq --raw-output 'if type=="array" then . | length else "" end' <<< "$this_var_value" 2> /dev/null )"; then
				variable_color="${GREEN}"
			fi
		fi

		printf "${DGRAY}%s ${variable_color}%-${max_length}.${max_length}s ${CYAN}%8.8s %4.4s  ${DGRAY}'${NOCOLOR}%s${DGRAY}' ${DGRAY}%s${NOCOLOR}\n" "$debug_prefix" "$this_var_name" "$this_var_status" "$JSON_array_size" "$this_var_value"

		(( total_vars_size += this_var_size,
		total_vars_count++ ))
	done

	if (( total_vars_count > 1 )); then
		printf "${DGRAY}%s %u var(s), %u bytes${NOCOLOR}\n" "$debug_prefix" $(( total_vars_count )) $(( total_vars_size ))
	fi
} 1>&2

function jq_batch_process {
	#
	# Usage: jq_batch_process 'jq_batch_request_hashtable_by_ref' 'JSON_input_by_ref'
	#

	# args
	local -r jq_batch_request_hashtable_by_ref="${1-}"
	local -r JSON_input_by_ref="${2-}"

	# vars by ref
	local -r -n _jq_batch_request_hashtable="$jq_batch_request_hashtable_by_ref"
	local -r -n JSON_input="$JSON_input_by_ref"

	# vars
	local jq_batch_response_raw
	local -A jq_batch_response_hashtable=()
	local -a jq_batch_response_raw_array=()
	local this_var this_value this_key
	#
	local jq_batch_script='">>BEGIN JQ RESPONSE", ( ' # .[1] |
	local -i this_index=1

	# code
	#
	# 1. assemble the big fat jq batch script with markup
	# 2. reset output vars to null
	#
	for this_var in "${!_jq_batch_request_hashtable[@]}"; do
		# reset output vars to null
		local -n this_var_ref="$this_var"
		this_var_ref='null'

		jq_batch_script+="( \">>BEGIN KEY ${this_var}\", try ( ${_jq_batch_request_hashtable[$this_var]} ) catch null, \"<<END KEY ${this_var}\" )"
		if (( this_index++ < ${#_jq_batch_request_hashtable[@]} )); then
			jq_batch_script+=','
		else
			jq_batch_script+=' ), "<<END JQ RESPONSE"'
		fi
		#jq_batch_script+=$'\n' # pretty-print for debug
	done
	#echo "$jq_batch_script"

	#
	# 3. process jq batch script then get the output to array
	#
	if is_JSON_string_not_empty_or_null "$JSON_input"; then
		#echo "'$JSON_input'" && snore 1
		jq_batch_response_raw="$( jq --compact-output --argjson 'max_fan_rpm' "$ASIC_MAX_FAN_RPM" "$jq_batch_script" <<< "$JSON_input" )"
		#                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duct tape, might refactor to get rid of it?
		mapfile -t jq_batch_response_raw_array <<< "$jq_batch_response_raw"
		#printf "%s\n" "${jq_batch_response_raw_array[@]}"

		for this_index in "${!jq_batch_response_raw_array[@]}"; do
			this_value="${jq_batch_response_raw_array[this_index]}"
			case "$this_value" in
				'">>BEGIN JQ RESPONSE"')
					# first element
					continue
				;;
				'">>BEGIN KEY '*'"')
					this_key="${this_value//\"}" # remove quotes
					this_key="${this_key##* }" # get last token from string
					#echo "{ # BEGIN $this_key"
					jq_batch_response_hashtable["$this_key"]='null' # let us make it as ='null' by default and then get rid of a argjson_sanitizing
					continue
				;;
				'"<<END KEY '*'"')
					#echo "} # END $this_key"
					this_key='__undefined_key'
					continue
				;;
				'"<<END JQ RESPONSE"')
					break
				;;
				*)
					#echo "	$this_key=$this_value"
					if [[ -n "$this_key" && "$this_key" != '__undefined_key' ]]; then
						jq_batch_response_hashtable["$this_key"]="$this_value"
					else
						errcho "this_key $this_key, this_value $this_value"
					fi
				;;
			esac
		done

		#
		# 4. assign each element of array to the corresponding output var
		#
		for this_var in "${!_jq_batch_request_hashtable[@]}"; do
			this_value="${jq_batch_response_hashtable[$this_var]}"
			if [[ -z "$this_value" ]]; then
				this_value='null'
				errcho "this_var $this_var=$this_value"
			fi
			local -n this_var_ref="$this_var"
			# shellcheck disable=SC2034
			# bc it's a ref var
			this_var_ref="$this_value"
			#echo "$this_var=$this_var_ref"
		done
	else
		errcho "$JSON_input_by_ref variable is empty"
	fi
}

function screen_session_terminate {
	#
	# Usage: screen_session_terminate 'screen_session_name'
	#

	# args
	local -r screen_session_name="${1-}"

	# code
	# shellcheck disable=SC2154
	# bc exitcode_ERROR_SOMETHING_WEIRD declared in library
	[[ -z "$screen_session_name" ]] && return $(( exitcode_ERROR_SOMETHING_WEIRD )) ### TODO rework
	screen -S "$screen_session_name" -X quit > /dev/null
}

function milliseconds_to_seconds {
	#
	# Usage: milliseconds_to_seconds 'milliseconds'
	#

	# args
	local -r -i milliseconds="${1-}"

	# vars
	local -i s_part ms_part
	local ms_part_left_padded sign

	# code
	if (( milliseconds > 0 )); then
		sign=''
	else
		milliseconds=0-milliseconds
		sign='-'
	fi

	(( s_part = milliseconds / 1000,
	ms_part = milliseconds % 1000 / 10 ))
	printf -v ms_part_left_padded '%02u' "$ms_part" # let's leave only 2 digits after the dot bc we don't have a milli precision actually

	if (( ms_part == 0 )); then
		# 1.00 -> 1
		printf '%s%u\n' "$sign" "$s_part"
	elif (( ms_part % 10 == 0 )); then
		# 1.10 -> 1.1
		printf '%s%u.%s\n' "$sign" "$s_part" "${ms_part_left_padded::1}"
	else
		# 1.11 -> 1.11
		printf '%s%u.%s\n' "$sign" "$s_part" "$ms_part_left_padded"
	fi
}

function get_time_difference_in_s {
	#
	# Usage: get_time_difference_in_s 'start_time_in_ms'
	#

	# args
	local -r -i start_time_in_ms="${1-}"

	# vars
	local -i finish_time_in_ms wasted_time_in_ms
	local time_difference_in_s

	# code
	finish_time_in_ms="$( get_system_uptime_in_milliseconds )"
	(( wasted_time_in_ms = finish_time_in_ms - start_time_in_ms ))
	time_difference_in_s="$( milliseconds_to_seconds $(( wasted_time_in_ms )) )"

	echo "$time_difference_in_s"
}

function reduce_hashrate_to_khs {
	#
	# Usage: reduce_hashrate_to_khs 'input_hashrate_value' 'hs|khs|mhs|ghs|ths|phs' 'output_hashrate_in_khs_by_ref'
	#

	# args
	local -r input_hashrate_value="${1-0}"
	local -r input_hashrate_unit="${2-khs}" # khs is the Hive default
	local -r -n output_hashrate_in_khs_by_ref="${3-}"

	# consts
	local -r -A relationship_to_khs_DICT=(
		['phs']='1000000000000'
		['ths']='1000000000'
		['ghs']='1000000'
		['mhs']='1000'
		['khs']='1'
		['hs']='0.001'
	)

	# vars
	local input_hashrate_unit_SAFE relationship_to_khs

	# code

	# first sanitize input_hashrate_unit
	input_hashrate_unit_SAFE="${input_hashrate_unit,,}" # tolower()
	input_hashrate_unit_SAFE="${input_hashrate_unit_SAFE//\/}" # strip an eventual '/'

	if [[ "$input_hashrate_value" == '0' || "$input_hashrate_value" == 'null' || "$input_hashrate_unit_SAFE" == 'khs' ]]; then
		# don't have to calculate anything, just pass input to output
		output_hashrate_in_khs_by_ref="$input_hashrate_value"
		# shellcheck disable=SC2154
		# bc exitcode_OK declared in library
		return $(( exitcode_OK ))
	fi

	relationship_to_khs="${relationship_to_khs_DICT[$input_hashrate_unit_SAFE]-}"
	if [[ -z "$relationship_to_khs" ]]; then
			errcho "Hashrate unit not in dictionary: '$input_hashrate_unit'"
			# shellcheck disable=SC2154
			# bc exitcode_ERROR_NOT_FOUND declared in library
			return $(( exitcode_ERROR_NOT_FOUND ))
	fi

	if [[ "${input_hashrate_value}${relationship_to_khs}" == *[0-9].[0-9]* ]]; then
		# it's FP and we need awk then
		# shellcheck disable=SC2034
		output_hashrate_in_khs_by_ref="$(
			awk -v input_hashrate_value="$input_hashrate_value" \
				-v relationship_to_khs="$relationship_to_khs" \
				'BEGIN{ print input_hashrate_value * relationship_to_khs }'
		)"
	else
		# all integer
		# shellcheck disable=SC2034
		# bc it's by ref
		(( output_hashrate_in_khs_by_ref = input_hashrate_value * relationship_to_khs ))
	fi
}

function send_request_to_miner_api {
	#
	# Usage: send_request_to_miner_api 'request_body'
	#

	# args
	local -r request_body="${1-}"

	# consts
	local -r -i timeout=7

	# code
	case "$ASIC_MODEL" in
		'Zig Z1+'|'Zig Z1')
			timeout "$timeout" nc "$miner_API_host" "$miner_API_port" <<< "$request_body" 2> /dev/null
		;;

		*)
			timeout -t "$timeout" nc "$miner_API_host" "$miner_API_port" <<< "$request_body" 2> /dev/null
		;;
	esac | tr -d '\0\n' # sanitize

	return "${PIPESTATUS[0]}"
}

function get_stats_raw {
	#
	# Usage: get_stats_raw
	#

	send_request_to_miner_api '{"command":"stats"}'
}

function get_pools_raw {
	#
	# Usage: get_pools_raw
	#

	send_request_to_miner_api '{"command":"pools"}'
}

function process_pools {
	#
	# !!! may change var from global scope: system_status
	# !!! may change vars from outer scope: POOLS active_pool_id
	#

	# consts
	local -r active_pool_id_RE='^[0-9]+$'

	# vars
	local pools_raw

	# code
	if pools_raw="$( get_pools_raw )"; then
		if POOLS="$( jq --compact-output '.POOLS' <<< "$pools_raw" )"; then
			if active_pool_id="$( jq --raw-output '[. as $object | keys[] | select($object[.]."Stratum Active" == true and $object[.]."Priority" <= 3) as $pool | select($object[$pool]."Getworks")] | .[0]' <<< "$POOLS" 2> /dev/null )"; then
				if [[ "$active_pool_id" =~ $active_pool_id_RE ]]; then
					: ok good to go
				else
					log_line warning 'All user pools are not alive:'
					jq --color-output --compact-output \
						'.[] |
							select( .Priority <= 3 ) |
								with_entries(
									select(
										.key |
											test( "Stratum Active", "URL", "User", "Status", "Priority" )
									)
								)' \
						<<< "$POOLS"
					echo
					case "$system_status" in
						'mining' | 'tuning' | 'NA' )
							system_status='deadpool'
						;;
					esac
					return $(( exitcode_ERROR_NOT_FOUND ))
				fi
			else
				log_line warning 'No active pools yet'
				return $(( exitcode_ERROR_NOT_FOUND ))
			fi
		else
			log_line warning 'No pools yet'
		fi
	else
		log_line warning "Failed to read pool stats from $miner_API_host:$miner_API_port"
	fi
}

function cache_cmd {
	#
	# Usage: cache_cmd cmd args...
	#

	# args
	# $@ used down south

	# debug
	if (( script_DEBUG )); then
		local -r -i this_function_DEBUG=1
	else
		local -r -i this_function_DEBUG=0 # set to '1' if you'd fancy to debug this function only
	fi
	(( this_function_DEBUG )) && local -i time_start_caching_in_ms="$( get_system_uptime_in_milliseconds )" # start the timing with millisecond resolution

	# consts
	local -r -i cache_ttl_in_s=50
	local -r cache_FILE='/run/hive/cmd_cache'
	local hash; printf -v hash "%s<FD>" "${@:1:2}" # construct a hash from the first two elements in "$@", literalize fields delimiters
	local -r       last_time_KEY="$hash:last_time"
	local -r cached_response_KEY="$hash:cached_response"
	local -r cached_exitcode_KEY="$hash:cached_exitcode"
	local -r   avg_cold_time_KEY="$hash:avg_cold_time"
	local -r  avg_hot_time_KEY="$hash:avg_hot_time"

	# hashes
	# shellcheck disable=SC1090
	local -A cmd_cache_array; [[ -s "$cache_FILE" ]] && source "$cache_FILE"
	# direct refs to array elements
	local -n       last_time="cmd_cache_array['$last_time_KEY']"
	local -n cached_response="cmd_cache_array['$cached_response_KEY']"
	local -n cached_exitcode="cmd_cache_array['$cached_exitcode_KEY']"
	local -n   avg_cold_time="cmd_cache_array['$avg_cold_time_KEY']"
	local -n    avg_hot_time="cmd_cache_array['$avg_hot_time_KEY']"

	# flags
	local -i is_cold_FLAG=0

	# vars
	local -i current_time time_wasted_caching_in_ms cache_efficiency
	local debug_message tip=''

	# code
	current_time="$( get_current_system_time_in_seconds )"

	[[ -z "$last_time" ]] && last_time=0

	# shellcheck disable=SC2004
	# bc $/${} is necessary while the variable been referenced to an array's single element

	#     vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv -- 1. a usual case when the cache is stale
	if (( ( ( $last_time + cache_ttl_in_s ) < current_time ) || ( $last_time > current_time ) )); then
		#                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ -- 2. an edge case when the last time is from the future, magically
		#     ^ fix an unknown bash issue: variable with a reference to a single array element inside an ((arithmetic context))

		# refresh the cache
		cached_response="$( "$@" )"
		cached_exitcode=$?
		last_time="$current_time"
		is_cold_FLAG=1
	fi

	if (( this_function_DEBUG )); then
		# do timing, averaging, profiling and stuff
		time_wasted_caching_in_ms="$(( $( get_system_uptime_in_milliseconds ) - time_start_caching_in_ms ))"

		if (( is_cold_FLAG )); then
			# shellcheck disable=SC2004
			# bc $/${} is necessary while the variable been referenced to an array's single element
			debug_message="exec '${*:1:2}' (exitcode $cached_exitcode), cache age $(( current_time - $last_time ))s"
			if [[ -z "$avg_cold_time" || "$avg_cold_time" -eq 0 ]]; then
				avg_cold_time="$time_wasted_caching_in_ms"
			else
				# shellcheck disable=SC2004
				# bc $/${} is necessary while the variable been referenced to an array's single element
				avg_cold_time=$(( ( $avg_cold_time + time_wasted_caching_in_ms ) / 2 ))
			fi
		else
			# shellcheck disable=SC2004
			# bc $/${} is necessary while the variable been referenced to an array's single element
			debug_message="cache '${*:1:2}' (exitcode $cached_exitcode), cache age $(( current_time - $last_time ))s"
			if [[ -z "$avg_hot_time" || "$avg_hot_time" -eq 0 ]]; then
				avg_hot_time="$time_wasted_caching_in_ms"
			else
				# shellcheck disable=SC2004
				# bc $/${} is necessary while the variable been referenced to an array's single element
				avg_hot_time=$(( ( $avg_hot_time + time_wasted_caching_in_ms ) / 2 ))
			fi
		fi

		# these vars aren't -i(nteger), so good old [[ ]] testing is way more appropriate than (( ))
		if (( ${avg_hot_time:-0} && ${avg_cold_time:-0} )); then
			# shellcheck disable=SC2004
			# bc $/${} is necessary while the variable been referenced to an array's single element
			(( cache_efficiency = ( $avg_cold_time - $avg_hot_time ) * 100 / $avg_hot_time ))
			(( cache_efficiency <= 100 )) && tip='(caching is not recommended)'
		fi

		log_line debug "$debug_message, avg hot/cold time ${avg_hot_time:--}ms/${avg_cold_time:--}ms, efficiency ${cache_efficiency:--}% $tip" 1>&2
	fi

	# shellcheck disable=SC2034
	# bc cmd_cache_array is used in a weird way lol
	(( is_cold_FLAG )) && declare -p cmd_cache_array > "$cache_FILE" # refresh the cache only if cold

	[[ -n "$cached_response" ]] && echo "$cached_response"
	return "$cached_exitcode"
}

function fetch_miner_stats {
	#
	# Usage: fetch_miner_stats 'miner_name'
	#

	# args
	local miner_name="$1"

	# vars
	local stats_raw stats_dev_raw STATS
	local uptime hashrate_raw
	local POOLS active_pool_id
	local hs temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_acn chain_acs chain_voltage hw_errors power asicboost ar

	# arrays
	local -a error_vars=() # must be empty

	# functions
	function sanitize_total_khs {
		# show vars with errors, if any
		(( ${#error_vars[@]} )) && log_line debug "Missing API keys: ${error_vars[*]}"
		is_JSON_string_empty_or_null "$total_khs" && total_khs=0
	}

	# code
	total_khs=0	# reset the global var
	stats=''	# reset the global var

	case "$ASIC_MODEL" in
		'Antminer '						|\
		'Antminer E3'					|\
		'Antminer S9'|'Antminer S9i'|'Antminer S9j'|'Antminer S9 SE'|'Antminer S9 Hydro'|'Antminer S9 (vnish'*|'Antminer S9'*|'Minecenter S9'|\
		'Antminer S10'*					|\
		'Antminer S11'					|\
		'Antminer S15'					|\
		'Antminer S17'*					|\
		'Antminer S19'*					|\
		'Antminer T19'*					|\
		'Antminer T9+'*|'Antminer T9'*	|\
		'Antminer T15'					|\
		'Antminer T17'*					|\
		'Antminer X17'*)
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n' | sed 's/}{/},{/' | jq '.'
			if ! stats_raw="$( get_stats_raw )" || [[ -z "$stats_raw" ]]; then
				system_status="$( ant-functions.sh 'hiveon_status' 'ERR_NO_STATS' )" # check for 'tuning' state
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
				{ sanitize_total_khs; return; }
			fi

			# fix a broken API answer (like S9): '}{' -> '},{'                    vvvvvvvvvvv
			STATS="$( jq --compact-output '.STATS'				<<< "${stats_raw//\}\{/\},\{}" 2> /dev/null )"	|| error_vars+=( "STATS#$?" )
			hashrate_raw="$( jq --raw-output '.[1]."GHS 5s"'	<<< "$STATS" 2> /dev/null )"					|| error_vars+=( "hashrate_raw#$?" )

			# choose what units will be used
			if [[ -n "$ASIC_TOTAL_HASHRATE_UNITS" ]]; then
				reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_TOTAL_HASHRATE_UNITS" 'total_khs'
			else
				reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'
			fi

			system_status="$( ant-functions.sh 'hiveon_status' "$STATS" )"

			process_pools || { sanitize_total_khs; return; }

			uptime="$(			jq --raw-output		'.[1].Elapsed'																																			<<< "$STATS" 2> /dev/null )" || error_vars+=( "uptime#$?" )
			hs="$(				jq --compact-output	'.[1] | with_entries( select(.key | test("chain_rate\\d+")) )	| to_entries | [ .[].value | if . != "" then tonumber else 0 end ]'						<<< "$STATS" 2> /dev/null )" || error_vars+=( "hs#$?" )
			temp="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("temp2_\\d+")) )		| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "temp#$?" )
			chip_temp="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("temp_chip\\d+")))		| to_entries | [ .[].value | split("-") | max | if . != "" then tonumber else "" end ]'	<<< "$STATS" 2> /dev/null )" || error_vars+=( "chip_temp#$?" )
			board_temp="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("temp\\d+$")) )		| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "board_temp#$?" )
			fan_percent="$(		jq --compact-output --argjson max_fan_rpm "$ASIC_MAX_FAN_RPM" \
													'.[1] | with_entries( select(.key | test("fan\\d+")) )			| to_entries | [ .[].value / $max_fan_rpm * 100 + 0.5 | floor ]'						<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan_percent#$?" )
			fan_rpm="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("fan\\d+")) )			| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan_rpm#$?" )
			freq="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("freq_avg\\d+")) )		| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "freq#$?" )
			freq_new="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("freq\\d+")) )			| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "freq_new#$?" )
			chain_acn="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acn\\d+")) )	| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acn#$?" )

# experimental traffic reduction algo
#			# TODO move to init section like [[ -s /hive-config/use-smart-acs ]] && use_smart_acs_FLAG=1
#			if [[ -s /hive-config/use-smart-acs ]]; then
#				case "$( < /hive-config/use-smart-acs )" in
#					'ok')	log_line warning 'smart-acs traffic reduction: OK mode'
#							chain_acs="$(
#								jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [ .[].value | if test("^[ o]+$") then "ok" else . end ] | if (unique_by(.=="") | length) == 1 then [] else . end'	<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acs#$?" )
#							;;
#					'full')	log_line warning 'smart-acs traffic reduction: FULL mode'
#							chain_acs="$(
#								jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [ .[].value | if test("^[ o]+$") then "" else . end ] | if (unique_by(.=="") | length) == 1 then [] else . end'		<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acs#$?" )
#							;;
#				esac
#			else
#				chain_acs="$(	jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acs#$?" )
#			fi

			chain_acs="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acs#$?" )
			chain_voltage="$(	jq --compact-output	'.[1] | with_entries( select(.key | test("chain_voltage\\d+")) )| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_voltage#$?" )
			hw_errors="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_hw\\d+")) )		| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "hw_errors#$?" )
#			power="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_power\\d+")) )	| to_entries | [ .[].value ]'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "power#$?" )
			power="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_power\\d+")) )	| to_entries | from_entries'															<<< "$STATS" 2> /dev/null )" || error_vars+=( "power#$?" )
			asicboost="$(		jq					'.[1] | with_entries( select(.key | test("chain_power$")) )		| to_entries | .[].value | test("AB") | if . == true then 1 else 0 end'					<<< "$STATS" 2> /dev/null )" || error_vars+=( "asicboost#$?" )
			ar="$(				jq --compact-output --argjson pool "$active_pool_id" \
													'.[$pool] | with_entries( select(.key | test("^Accepted","^Rejected","Get Failures")) ) | to_entries | [.[].value]'										<<< "$POOLS" 2> /dev/null )" || error_vars+=( "ar#$?" )

			if (( IS_ASIC_CUSTOM_FW )); then
				[[ "$chain_voltage" == '[]'	]] && chain_voltage="$( cache_cmd ant-functions.sh 'hiveon_voltage' <<< "$chain_acn" )"
				[[ "$power" != '{}'			]] && power="$( cache_cmd ant-functions.sh 'hiveon_power' "$power" "$chain_acn" )"
			fi

			[[ "$chip_temp" =~ .[0-9]	]] && temp="$chip_temp"
			[[ "$freq_new" =~ .[0-9]	]] && freq="$freq_new"

			stats="$( jq --null-input --compact-output																		\
				--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
				--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
				--argjson	'board_temp'	"${board_temp:-null}"			--argjson	'fan'		"${fan_percent:-null}"	\
				--argjson	'fan_rpm'		"${fan_rpm:-null}"				--argjson	'freq'		"${freq:-null}"			\
				--argjson	'chain_voltage'	"${chain_voltage:-null}"		--argjson	'acn'		"${chain_acn:-null}"	\
				--argjson	'power'			"${power:-null}"				--argjson	'hw_errors'	"${hw_errors:-null}"	\
				--argjson	'status'		"${chain_acs:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
				--argjson	'ar'			"${ar:-null}"					--argjson	'asicboost'	"${asicboost:-null}"	\
																															\
				'{$algo,$hs,$hs_units,$temp,$board_temp,$fan,$fan_rpm,$freq,$chain_voltage,$acn,$power,$hw_errors,$status,$uptime,$ar,$asicboost}' \
																															\
				2> /dev/null
			)" || error_vars+=( "stats#$?" )
			(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
		;;

		'Antminer A3'										|\
		'Antminer D3'|'Antminer D3 Blissz'*|'Antminer DR3'	|\
		'Antminer L3+'*										|\
		'Antminer S7'										|\
		'Antminer X3'										|\
		'Antminer Z9'*										|\
		'Antminer Z11'*)
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
log_line debug 'get_stats_raw()'
			if ! stats_raw="$( get_stats_raw )" || [[ -z "$stats_raw" ]]; then
				system_status="$( ant-functions.sh 'hiveon_status' 'ERR_NO_STATS' )" # check for 'tuning' state
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
				{ sanitize_total_khs; return; }
			fi

			# fix a broken API answer (like S9): '}{' -> '},{'       vvvvvvvvvvv
			STATS="$( jq --compact-output '.STATS' <<< "${stats_raw//\}\{/\},\{}" 2> /dev/null )" || error_vars+=( "STATS#$?" )

			system_status="$( ant-functions.sh 'hiveon_status' "$STATS" )"
			process_pools || { sanitize_total_khs; return; }

			# jq batch optimization for a weak CPUs like L3+, Z9 etc.
			# shellcheck disable=SC2034
			# bc it's by ref
			local -A -r jq_batch_request_hashtable=(
				['hashrate_raw']='		.[1] | ."GHS 5s"				| tonumber'
				['uptime']='			.[1] | .Elapsed'
				['hs']='				.[1] | with_entries(select(.key | test("chain_rate\\d+")))				| to_entries | [ .[].value | if . != "" then tonumber else 0 end  ]'
				['temp']='				.[1] | with_entries(select(.key | test("temp2_\\d+")))					| to_entries | [ .[].value ]'
				['board_temp']='		.[1] | with_entries(select(.key | test("temp\\d+$")))					| to_entries | [ .[].value ]'
				['fan_percent']='		.[1] | with_entries(select(.key | test("fan\\d+")))						| to_entries | [ .[].value / $max_fan_rpm * 100 + 0.5 | floor ]'
				['fan_rpm']='			.[1] | with_entries(select(.key | test("fan\\d+")))						| to_entries | [ .[].value ]'
				['freq']='				.[1] | with_entries(select(.key | test("frequency\\d+")))				| to_entries | [ .[].value | if . != "" then tonumber else 0 end ]'
				['chain_acn']='			.[1] | with_entries(select(.key | test("chain_acn\\d+")))				| to_entries | [ .[].value ]'
				['chain_acs']='			.[1] | with_entries(select(.key | test("chain_acs\\d+")))				| to_entries | [ .[].value ]'
				['chain_voltage']='		.[1] | with_entries(select(.key | test("^([a-z]+_)?voltage\\d+$")))		| to_entries | [ .[].value ]'
				#                                                               ^^^^^^^^^^^^^^^^^^^^^^^ L3+ Hiveon has 'voltageN' keys, not 'chain_voltageN'
				['hw_errors']='			.[1] | with_entries(select(.key | test("chain_hw\\d+")))				| to_entries | [ .[].value ]'
				['power']='				.[1] | with_entries(select(.key | test("chain_power\\d+")))				| to_entries | [ .[].value + 0.5 | floor ]'
				#
				['freq_count']='		.[1] | with_entries(select(.key | test("frequency\\d+")) ) | length'
				['miner_count']='		.[1] | with_entries(select(.key | test("chain_acn\\d+")) ) | length'
			)
log_line debug 'jq_batch_process()'
			jq_batch_process 'jq_batch_request_hashtable' 'STATS'

#			hashrate_raw="$( jq --raw-output '.[1]."GHS 5s"'	<<< "$STATS" 2> /dev/null )"					|| error_vars+=( "hashrate_raw#$?" )
			# choose what units will be used
			if [[ -n "$ASIC_TOTAL_HASHRATE_UNITS" ]]; then
				reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_TOTAL_HASHRATE_UNITS" 'total_khs'
			else
				reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'
			fi

#			uptime="$(			jq --raw-output		'.[1].Elapsed'																																	<<< "$STATS" 2> /dev/null )" || error_vars+=( "uptime#$?" )
#			hs="$(				jq --compact-output	'.[1] | with_entries( select(.key | test("chain_rate\\d+")) )			| to_entries | [ .[].value | if . != "" then tonumber else "" end ]'	<<< "$STATS" 2> /dev/null )" || error_vars+=( "hs#$?" )
#			temp="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("temp2_\\d+")) )				| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "temp#$?" )
#			board_temp="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("temp\\d+$")) )				| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "board_temp#$?" )
#			fan_percent="$(		jq --compact-output --argjson max_fan_rpm "$ASIC_MAX_FAN_RPM" \
#													'.[1] | with_entries( select(.key | test("fan\\d+")) )					| to_entries | [.[].value / $max_fan_rpm * 100 + 0.5 | floor ]'			<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan_percent#$?" )
#			fan_rpm="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("fan\\d+")) )					| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "fan_rpm#$?" )
#			freq="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("frequency\\d+")) )			| to_entries | [ .[].value | if . != "" then tonumber else "" end ]'	<<< "$STATS" 2> /dev/null )" || error_vars+=( "freq#$?" )
#			chain_acn="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acn\\d+")) )			| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acn#$?" )
#			power="$(			jq --compact-output	'.[1] | with_entries( select(.key | test("chain_power\\d+")) )			| to_entries | [ .[].value + 0.5 | floor ]'								<<< "$STATS" 2> /dev/null )" || error_vars+=( "power#$?" )
#			chain_acs="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_acs\\d+")) )			| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_acs#$?" )
#			chain_voltage="$(	jq --compact-output	'.[1] | with_entries( select(.key | test("^([a-z]+_)?voltage\\d+$")) )	| to_entries | [ .[].value ]'											<<< "$STATS" 2> /dev/null )" || error_vars+=( "chain_voltage#$?" ) #' highlighting fix
			#                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^ L3+ Hiveon has 'voltageN' keys, not 'chain_voltageN'
#			hw_errors="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("chain_hw\\d+")) )				| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "hw_errors#$?" )

			ar="$(				jq --compact-output --argjson pool "$active_pool_id" \
												'.[$pool] | with_entries( select(.key | test("^Accepted","^Rejected","Get Failures")) ) | to_entries | [.[].value]'									<<< "$POOLS" 2> /dev/null )" || error_vars+=( "ar#$?" )

			if (( IS_ASIC_CUSTOM_FW )); then
				[[ "$chain_voltage" == '[]' ]] && chain_voltage="$( cache_cmd ant-functions.sh 'hiveon_voltage' <<< "$chain_acn" )"
			fi

			# shellcheck disable=SC2154
			# bc it's by ref
			if (( freq_count == miner_count )); then
				freq_new="$freq"
			else
				freq_new='[]'
				freq="$(		jq --compact-output	'.[1] | with_entries( select(.key | test("frequency")) )				| to_entries | [.[].value]'												<<< "$STATS" 2> /dev/null )" || error_vars+=( "freq#$?" )
				freq_num="$(	jq --raw-output '.[0]' <<< "$freq" )" || error_vars+=( "freq_num#$?" )
				for (( c = 1;  c <= miner_count; c++ )); do
					freq_new="$( jq --raw-output --arg freq_num "$freq_num" '[.[], $freq_num | tonumber]' <<< "$freq_new" )" || error_vars+=( "freq_new#$?" )
				done
			fi

			stats="$( jq --null-input --compact-output																					\
				--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"						\
				--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"						\
				--argjson	'board_temp'	"${board_temp:-null}"			--argjson	'fan'		"${fan_percent:-null}"				\
				--argjson	'fan_rpm'		"${fan_rpm:-null}"				--argjson	'freq'		"${freq_new:-null}"					\
				--argjson	'chain_voltage'	"${chain_voltage:-null}"		--argjson	'acn'		"${chain_acn:-null}"				\
				--argjson	'power'			"${power:-null}"				--argjson	'hw_errors'	"${hw_errors:-null}"				\
				--argjson	'status'		"${chain_acs:-null}"			--argjson	'uptime'	"${uptime:-null}"					\
				--argjson	'ar'			"${ar:-null}"																				\
																																		\
				'{$algo,$hs,$hs_units,$temp,$board_temp,$fan,$fan_rpm,$freq,$chain_voltage,$acn,$power,$hw_errors,$status,$uptime,$ar}'	\
																																		\
				2> /dev/null
			)" || error_vars+=( "stats#$?" )
			(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
		;;

		'Zig Z1+'	|\
		'Zig Z1')
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			if ! stats_raw="$( get_stats_raw )" || [[ -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
				{ sanitize_total_khs; return; }
			fi

			# fix a broken API answer (like S9): '}{' -> '},{'                    vvvvvvvvvvv
			STATS="$( jq --compact-output '.STATS'				<<< "${stats_raw//\}\{/\},\{}" 2> /dev/null )"	|| error_vars+=( "STATS#$?" )
			hashrate_raw="$( jq --raw-output '.[0]."MHS 30S"'	<<< "$STATS" 2> /dev/null )"					|| error_vars+=( "hashrate_raw#$?" )
			reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'

			uptime="$(		jq --raw-output		'.[0].Elapsed'																																												<<< "$STATS" )" || error_vars+=( "uptime#$?" )
			hs="$(			jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | ."MHS 30S"]'															<<< "$STATS" )" || error_vars+=( "hs#$?" )
			temp="$(		jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | ."Temperature"]'														<<< "$STATS" )" || error_vars+=( "temp#$?" )
			fan_percent="$(	jq --compact-output --argjson max_fan_rpm "$ASIC_MAX_FAN_RPM" \
												'.[0]						| with_entries( select(.key | test("Fan In|Fan Out") ) )	| to_entries | [.[].value / $max_fan_rpm * 100 + 0.5 | floor ]'										<<< "$STATS" )" || error_vars+=( "fan_percent#$?" )
			fan_rpm="$(		jq --compact-output	'.[0]						| with_entries( select(.key | test("Fan In|Fan Out") ) )	| to_entries | [.[].value ]'																		<<< "$STATS" )" || error_vars+=( "fan_rpm#$?" )
			freq="$(		jq --compact-output	'.[0].Frequency as $freq	| .[0] | with_entries( select(.key | test("CH\\d+") ) )		| to_entries | [.[].value | $freq ]'																<<< "$STATS" )" || error_vars+=( "freq#$?" )
			chain_acn="$(	jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | .status | length ]'														<<< "$STATS" )" || error_vars+=( "chain_acn#$?" )
			chain_acs="$(	jq --compact-output	'.[0]						| with_entries( select(.key | test("CH\\d+") ) )			| to_entries | [.[].value | .status | [.[].accept | if . > 0 then "o" else "x" end ] | join("") ]'	<<< "$STATS" )" || error_vars+=( "chain_acs#$?" )
#			hw_errors="$(	jq --compact-output	'.[1]						| with_entries( select(.key | test("chain_hw\\d+")) )		| to_entries | [.[].value]'																			<<< "$STATS" )" || error_vars+=( "hw_errors#$?" )

			stats="$( jq --null-input --compact-output																		\
				--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
				--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
				--argjson	'fan'			"${fan_percent:-null}"			--argjson	'fan_rpm'	"${fan_rpm:-null}"		\
				--argjson	'freq'			"${freq:-null}"					--argjson	'acn'		"${chain_acn:-null}"	\
				--argjson	'status'		"${chain_acs:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
																															\
				'{$algo, $hs, $hs_units, $temp, $fan, $fan_rpm, $freq, $acn, $status, $uptime}'								\
																															\
				2> /dev/null
			)" || error_vars+=( "stats#$?" )
			(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
		;;

		'b29+.g19'						|\
		'a9+.g19'						|\
		'd9.g19'						|\
		's11.g19'						|\
		't2t.soc'|'t2t+.soc'			|\
		't2th.soc'|'t2th+.soc'|'t2thf.soc'|'t2thf+.soc'|'t2thl+.soc'|'t2thm.soc'|\
		't2ti.soc'						|\
		't2ts.soc'						|\
		't2tz.soc'						|\
		't1.g19'						|\
		't3.soc'|'t3+.soc'|'t3h+.soc')
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			if ! stats_raw="$( get_stats_raw )" || [[ -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
				{ sanitize_total_khs; return; }
			fi

			STATS="$( jq --compact-output '.STATS' <<< "$stats_raw" )"
			hashrate_raw="$( jq --raw-output '.[-1] | .[] | add' < /tmp/stats.json )"
			reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'

			uptime="$(		jq --raw-output		'.[0].Elapsed'																											<<< "$STATS"		)"
			hs="$(			jq --raw-output		'[.[-1] | .[] | .[]]'																									< /tmp/stats.json	)" || error_vars+=( "hs#$?" )
			temp="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("^Temp$")) )			| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "temp#$?" )
			fan_percent="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("^Fan duty$")) )		| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "fan_percent#$?" )
			freq="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("^PLL")) )				| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "freq#$?" )
			chain_acn="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("Num chips")) )		| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "chain_acn#$?" )
			chain_acs="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("Num active chips")) )	| to_entries | .[].value]'								<<< "$STATS"		)" || error_vars+=( "chain_acs#$?" )
			hw_errors="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("HW errors")) )		| to_entries | [.[].value] | add | select(.!=null)]'	<<< "$STATS"		)" || error_vars+=( "hw_errors#$?" )

			stats="$( jq --null-input --compact-output																		\
				--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
				--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
				--argjson	'fan'			"${fan_percent:-null}"			--argjson	'freq'		"${freq:-null}"			\
				--argjson	'acn'			"${chain_acn:-null}"			--argjson	'hw_errors'	"${hw_errors:-null}"	\
				--argjson	'status'		"${chain_acs:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
																															\
				'{$algo, $hs, $hs_units, $temp, $fan, $freq, $acn, $hw_errors, $status, $uptime}'							\
																															\
				2> /dev/null
			)" || error_vars+=( "stats#$?" )
			(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
		;;

		'T4.G19')
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			if ! stats_raw="$( send_request_to_miner_api '{"command":"devs"}' )" || [[ -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
				{ sanitize_total_khs; return; }
			fi

			STATS="$( jq --compact-output '.DEVS' <<< "$stats_raw" )"
			hashrate_raw="$( jq --raw-output '[.[]["MHS av"]] | add' <<< "$STATS" )"
			reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'

			uptime="$(		jq --raw-output		'.[0]["Device Elapsed"]'																	<<< "$STATS" )"
			hs="$(			jq --compact-output	'[.[] | with_entries( select(.key | test("MHS 5s")) )			| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "hs#$?" )
			temp="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("TempAVG")) )			| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "temp#$?" )
			freq="$(		jq --compact-output	'[.[] | with_entries( select(.key | test("CORE")) )				| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "freq#$?" )
			chain_acn="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("DUTY")) )				| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "chain_acn#$?" )
#			chain_acs="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("Num active chips")) )	| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "chain_acs#$?" )
			hw_errors="$(	jq --compact-output	'[.[] | with_entries( select(.key | test("Hardware Errors")) )	| to_entries | .[].value]'	<<< "$STATS" )" || error_vars+=( "hw_errors#$?" )

			stats="$( jq --null-input --compact-output																		\
				--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
				--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
				--argjson	'freq'			"${freq:-null}"					--argjson	'acn'		"${chain_acn:-null}"	\
				--argjson	'hw_errors'		"${hw_errors:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
																															\
				'{$algo, $hs, $hs_units, $temp, $freq, $acn, $hw_errors, $uptime}'											\
																															\
				2> /dev/null
			)" || error_vars+=( "stats#$?" )
			(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
		;;

		'Toddminer C1'*)
			stats="$( todd_api stats )"
			hashrate_raw="$( jq '.hs | add' <<< "$stats" )"
			reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'
			# shellcheck disable=SC2071
			# bc of float comparison
			[[ "$total_khs" > '0' ]] && system_status='mining'
			(( script_DEBUG )) && debug_print_variable stats
		;;

		'Blackminer F1'*)
			# echo '{"command":"stats"}' | timeout -t 7 nc localhost 4028 | tr -d '\0\n'
			if ! stats_raw="$( get_stats_raw )" || [[ -z "$stats_raw" ]]; then
				log_line warning "Failed to read $miner_name stats from $miner_API_host:$miner_API_port"
				{ sanitize_total_khs; return; }
			fi

			# fix a broken API answer (like S9): '}{' -> '},{'       vvvvvvvvvvv
			STATS="$( jq --compact-output '.STATS' <<< "${stats_raw//\}\{/\},\{}" )"

			local COIN="$( jq --raw-output '."coin-type"' < /config/cgminer.conf )"
			POWER=( '50' )
			if [[ -e /hive/share/blackminer/blackminer.json ]] && BBDATA="$( jq --exit-status '.' < /hive/share/blackminer/blackminer.json )"; then
					ASIC_ALGO="$( jq --raw-output --arg coin "$COIN" '.[$coin].algo' <<< "$BBDATA" )"	|| error_vars+=( "ASIC_ALGO#$?" )
					POWER="$( jq --raw-output --arg coin "$COIN" '.[$coin].power' <<< "$BBDATA" )"		|| error_vars+=( "POWER#$?" )
			fi

			hashrate_raw="$( jq --raw-output '.[1]."GHS 5s"' <<< "$STATS" )" #14162.91 gh/s = 14 th/s
			reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'
			process_pools || { sanitize_total_khs; return; }

			uptime="$(		jq --raw-output		'.[1].Elapsed'																													<<< "$STATS" )" || error_vars+=( "uptime#$?" )
			hs="$(			jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_rate\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "hs#$?" )
#			temp="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("temp2_\\d+")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "temp#$?" )
			temp="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("temp\\d+$")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "temp#$?" )
			board_temp="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("temp\\d+$")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "board_temp#$?" )
			fan_percent="$(	jq --compact-output --argjson max_fan_rpm "$ASIC_MAX_FAN_RPM" \
												'.[1]	| with_entries( select(.key | test("fan\\d+")) )		| to_entries | [.[].value / $max_fan_rpm * 100 + 0.5 | floor ]'	<<< "$STATS" )" || error_vars+=( "fan_percent#$?" )
			fan_rpm="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("fan\\d+")) )		| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "fan_rpm#$?" )
			freq="$(		jq --compact-output	'.[1]	| with_entries( select(.key | test("frequency\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "freq#$?" )
			miner_count="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("miner_count")) )	| to_entries | .[].value'										<<< "$STATS" )" || error_vars+=( "miner_count#$?" )
			chain_acn="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_acn\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "chain_acn#$?" )
			chain_acs="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_acs\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "chain_acs#$?" )
			hw_errors="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("chain_hw\\d+")) )	| to_entries | [.[].value]'										<<< "$STATS" )" || error_vars+=( "hw_errors#$?" )
			ar="$(			jq --compact-output --argjson pool "$active_pool_id" \
								'.[$pool] | with_entries( select(.key | test("^Accepted","^Rejected","Get Failures")) ) | to_entries | [.[].value]'	<<< "$POOLS" )" || error_vars+=( "ar#$?" )

			if [[ "$( jq --raw-output length <<< "$freq" )" -ne "$miner_count" ]]; then
				freq_new='[]'
				freq="$(	jq --compact-output	'.[1]	| with_entries( select(.key | test("frequency")) )		| to_entries | [.[].value]'										<<< "$STATS" )"
				freq_num="$( jq --raw-output '.[0]' <<< "$freq" )"
				for (( c=1; c<=miner_count; c++ )); do
					freq_new="$( jq --raw-output --arg freq_num "$freq_num" '[.[], $freq_num | tonumber]' <<< "$freq_new" )"
				done
			else
				freq_new="$freq"
			fi

			power="$( jq --slurp --compact-output '.' <<< "$POWER" )"

			stats="$( jq --null-input --compact-output																		\
				--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
				--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
				--argjson	'board_temp'	"${board_temp:-null}"			--argjson	'fan'		"${fan_percent:-null}"	\
				--argjson	'fan_rpm'		"${fan_rpm:-null}"				--argjson	'freq'		"${freq_new:-null}"		\
				--argjson	'acn'			"${chain_acn:-null}"			--argjson	'power'		"${power:-null}"		\
				--argjson	'ar'			"${ar:-null}"					--argjson	'hw_errors'	"${hw_errors:-null}"	\
				--argjson	'status'		"${chain_acs:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
																															\
				'{$algo,$hs,$hs_units,$temp,$board_temp,$fan,$fan_rpm,$freq,$acn,$power,$ar,$hw_errors,$status,$uptime}'	\
																															\
				2> /dev/null
			)" || error_vars+=( "stats#$?" )
			(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
		;;

		'Avalon'*)
			if ! stats_raw="$( /hive/bin/avalon_api 'status' )" || [[ -z "$stats_raw" ]]; then
				log_line warning "Failed to get 'status' from Avalon API"
				{ sanitize_total_khs; return; }
			fi

			if ! stats_dev_raw="$( /hive/bin/avalon_api 'stats' )" || [[ -z "$stats_dev_raw" ]]; then
				log_line warning "Failed to get 'stats' from Avalon API"
			fi

			STATS="$(			jq --compact-output '.summary'	<<< "$stats_raw" )"		|| error_vars+=( "STATS#$?" )
#			STATS_DEV="$(		jq --compact-output '.stats'	<<< "$stats_dev_raw" )"	|| error_vars+=( "STATS_DEV#$?" )
			STATS_DEV="$(		jq --compact-output				<<< "$stats_dev_raw" )"	|| error_vars+=( "STATS_DEV#$?" )

			hashrate_raw="$(	jq --raw-output '[.["MHS av"]] | add' <<< "$STATS" )"	|| error_vars+=( "hashrate_raw#$?" )
			reduce_hashrate_to_khs "$hashrate_raw" "$ASIC_CHAIN_HASHRATE_UNITS" 'total_khs'

			uptime="$(			jq --raw-output		'.["Elapsed"]'																						<<< "$STATS" )"		|| error_vars+=( "uptime#$?" )
			hs="$(				jq --compact-output	'[. | with_entries( select(.key | test("MHS 5s")) )						| to_entries | .[].value]'	<<< "$STATS" )"		|| error_vars+=( "hs#$?" )
			temp="$(			jq --compact-output	'[.stats["0"] | with_entries( select(.key | test("AUC Temperature")) )	| to_entries | .[].value]'	<<< "$STATS_DEV" )"	|| error_vars+=( "temp#$?" )
			freq="$(			jq --compact-output	'[.[][][]."Freq" | with_entries( select(.key | test("CORE")) )			| to_entries | .[].value]'	<<< "$STATS_DEV" )"	|| error_vars+=( "freq#$?" )
#			chain_acn="$(		jq --compact-output	'[. | with_entries( select(.key | test("DUTY")) )						| to_entries | .[].value]'	<<< "$STATS" )"		|| error_vars+=( "chain_acn#$?" )
#			chain_acs="$(		jq --compact-output	'[. | with_entries( select(.key | test("Num active chips")) )			| to_entries | .[].value]'	<<< "$STATS" )"		|| error_vars+=( "chain_acs#$?" )
			hw_errors="$(		jq --compact-output	'[. | with_entries( select(.key | test("Hardware Errors")) )			| to_entries | .[].value]'	<<< "$STATS" )"		|| error_vars+=( "hw_errors#$?" )

			stats="$( jq --null-input --compact-output																		\
				--arg		'algo'			"$ASIC_ALGO"					--argjson	'hs'		"${hs:-null}"			\
				--arg		'hs_units'		"$ASIC_CHAIN_HASHRATE_UNITS"	--argjson	'temp'		"${temp:-null}"			\
				--argjson	'freq'			"${freq:-null}"																	\
				--argjson	'hw_errors'		"${hw_errors:-null}"			--argjson	'uptime'	"${uptime:-null}"		\
																															\
				'{$algo, $hs, $hs_units, $temp, $freq, $hw_errors, $uptime}'												\
																															\
				2> /dev/null
			)" || error_vars+=( "stats#$?" )
			(( script_DEBUG )) && debug_print_variable stats ASIC_ALGO hs ASIC_CHAIN_HASHRATE_UNITS temp chip_temp board_temp fan_percent fan_rpm freq freq_new chain_voltage chain_acn power hw_errors chain_acs uptime ar asicboost
		;;

		*)
			errcho "Unsupported ASIC model '$ASIC_MODEL'"
			MINER='unknown'
		;;
	esac

	{ sanitize_total_khs; return; }
}

function get_loadavg_as_json_array {
	# vars
	local LA_1m LA_5m LA_15m

	# code
	# /proc/loadavg: '1.24 1.25 1.34 3/251 5135'
	read -t 10 -r LA_1m LA_5m LA_15m _ < /proc/loadavg
	printf '[%0.1f,%0.1f,%0.1f]\n' "$LA_1m" "$LA_5m" "$LA_15m"
}

function get_diskfree_as_string {
	# arrays
	local -a lines_array last_line_array

	# vars
	local diskfree

	# code
	#df -h "/${ASIC_MOUNT_PATH}" | awk '{ print $4 }' | tail -n 1 | sed 's/%//'
	readarray -s 1 -t lines_array < <( df -h "/${ASIC_MOUNT_PATH}" )
	last_line_array=( ${lines_array[-1]} )
	diskfree="${last_line_array[3]/%%}"

	echo "$diskfree"
}

function get_mem_as_json_array {
	# vars
	local meminfo_parameter_field meminfo_size_field
	local -i MemTotal=-1 MemAvailable=-1

	# flags
	local -i is_both_parameters_read_ok_FLAG=0

	# code
	#MemTotal:        8074824 kB
	#MemFree:         5573512 kB
	#MemAvailable:    5697504 kB
	#Buffers:           51764 kB
	while read -t 10 -r meminfo_parameter_field meminfo_size_field _ || [[ -n "$meminfo_parameter_field" ]]; do
		[[ "$meminfo_parameter_field" == 'MemTotal:' ]] && (( MemTotal = meminfo_size_field ))
		[[ "$meminfo_parameter_field" == 'MemAvailable:' ]] && (( MemAvailable = meminfo_size_field ))
		if (( MemTotal != -1 && MemAvailable != -1 )); then
			is_both_parameters_read_ok_FLAG=1
			break
		fi
	done < /proc/meminfo

	if (( is_both_parameters_read_ok_FLAG )); then
		echo "[$(( MemTotal / 1024 )),$(( MemAvailable / 1024 ))]"
	else
		echo 'null'
	fi
}

function get_saved_last_cmd_id {
	# vars
	local saved_last_cmd_id

	# code
	if [[ -s "$last_cmd_id_FILE" ]]; then
		saved_last_cmd_id="$( < "$last_cmd_id_FILE" )"
		(( script_DEBUG )) && log_line debug "[DEBUG] $last_cmd_id_FILE content is $saved_last_cmd_id" 1>&2 # TODO modify library to bear this redirection
	else
		saved_last_cmd_id=''
	fi

	(( script_DEBUG )) && log_line debug "[DEBUG] saved_last_cmd_id is '$saved_last_cmd_id'" 1>&2
	echo "$saved_last_cmd_id"
}

function process_total_khs_and_arr {
	#
	# compute, display and write out 'arr' (Accepted/Rejected Ratio) and 'khs' files for Hashrate Watchdog and Averager
	#

	# vars
	local -i total_khs_integer
#	local arr_rounded_to_2 arr_to_display

	# code

	# !!! arr section temporary DISABLED
	# not required yet, disabled -- waiting for ARR Watchdog to come someday

#	if is_JSON_string_not_empty_or_null "$stats"; then
#		arr_rounded_to_2="$(
#			jq 'def roundit: . * 100.0 + 0.5 | floor / 100.0;
#				try (
#					.ar | . as [$accepted,$rejected,$incorrect] | add |
#					if . > 10 then
#						$accepted / . * 100 | roundit
#					else
#						null
#					end
#				)
#				catch null
#			' <<< "$stats"
#		)"
#	fi

#	if is_JSON_string_not_empty_or_null "$arr_rounded_to_2"; then
#		arr_to_display=" (${arr_rounded_to_2}% accepted)"
#		printf '%.0f\n' "$arr_rounded_to_2" > "$arr_FILE"
#	else
#		arr_to_display=''
#		printf 'null\n' > "$arr_FILE" # watchdog won't bark in case of null
#	fi
#	(( script_DEBUG )) && debug_print_variable 'arr_rounded_to_2'

	# total_khs section
	if [[ -z "$total_khs" || "$total_khs" == '0' || "$total_khs" == 'null' ]]; then
		total_khs_integer=0
	else
		total_khs_integer="$( scientific_to_integer "$total_khs" )"
	fi

	if (( total_khs_integer > 0 )); then
		log_line info "$MINER hashrate ${WHITE}$( khs_to_human_friendly_hashrate "$total_khs" )${NOCOLOR}$arr_to_display, stats collected in ${WHITE}${time_wasted_collecting_stats_in_s}s"
		echo "$total_khs" > "$total_khs_FILE" # write actual total_khs to file (for Hashrate Watchdog and Averager)
	else
		log_line warning "$MINER hashrate ${WHITE}0 H/s${NOCOLOR}$arr_to_display, stats collected in ${WHITE}${time_wasted_collecting_stats_in_s}s"
		echo '0' > "$total_khs_FILE" # write 0 khs to file (for Hashrate Watchdog and Averager)
	fi
}

function get_avg_khs_as_json {
	#
	# reads avg_khs JSON object from a corresponding file (prepared by averager)
	# NB: if file is older than some value, output nothing (anyway it will be null later)
	#

	# vars
	local -i the_now avg_khs_FILE_last_updated_time seconds_passed_since_last_updated

	# code
	if [[ -s "$avg_khs_FILE" ]]; then
		# check the file for freshness
		avg_khs_FILE_last_updated_time="$( get_file_last_modified_time_in_seconds "$avg_khs_FILE" )"
		set_variable_to_current_system_time_in_seconds 'the_now'

		(( seconds_passed_since_last_updated = the_now - avg_khs_FILE_last_updated_time ))

		if (( seconds_passed_since_last_updated < 120 )); then
			#                                     ^^^ TODO should set this time to double of averager's calculating interval
			# shellcheck disable=SC2005
			# bc it's a pure bash cat emulaton
			echo "$( < "$avg_khs_FILE" )"
		fi
	fi
}

function pretty_print_api_hosts {
	# args
	local -r hosts_list="${1-}"
	local -r -i list_index="${2-0}"

	# flags
	local -i is_iterator_before_list_index=1

	# arrays
	local -a hosts_list_ARR

	# vars
	local -i this_element
	local hosts_list_sanitized this_host

	# code
	hosts_list_sanitized="${hosts_list//http:\/\/}" # cut 'http://'
	hosts_list_sanitized="${hosts_list_sanitized//\.hiveos\.farm}" # cut '.hiveos.farm'

	read -t 10 -r -a hosts_list_ARR <<< "$hosts_list_sanitized"
	for (( this_element = 0; this_element < ${#hosts_list_ARR[@]}; this_element++ )); do
		this_host="${hosts_list_ARR[this_element]-ERR_UNDEFINED}"
		if (( this_element == list_index )); then
			hosts_list_ARR[this_element]="${DGRAY-}[${BGREEN-}${this_host}${DGRAY-}]${NOCOLOR-}"
			is_iterator_before_list_index=0
		elif (( is_iterator_before_list_index )); then
			hosts_list_ARR[this_element]="${RED-}${this_host}${NOCOLOR-}"
		else
			hosts_list_ARR[this_element]="${DGRAY-}${this_host}${NOCOLOR-}"
		fi
	done
	echo "${hosts_list_ARR[*]}"
}

function fetch_stats_and_push_them_to_server {
	# flags
	local -i is_server_push_went_ok_FLAG=0

	# arrays
	local -a latest_curl_log_as_array=()

	# vars
	local -i curl_exitcode
	local -i time_start_collecting_stats time_start_sending_stats the_now
	local time_wasted_collecting_stats_in_s time_wasted_sending_stats_in_s
	local PUSH_INTERVAL custom_interval_message
	local cpuavg df last_cmd_id avg_khs
	local -i current_RIG_CONF_last_updated_time=0 current_WALLET_CONF_last_updated_time=0
	local comm_quality_percentage
	local -i this_element this_element_counter=0
	local request_endpoint

	# code
	is_program_in_the_PATH 'jq' || log_line error 'jq not found'

	# RIG_CONF. load it only at the very start or if updated (considering modification time)
	if [[ -s "$RIG_CONF" ]] && current_RIG_CONF_last_updated_time="$( get_file_last_modified_time_in_seconds "$RIG_CONF" )"; then
		if (( saved_RIG_CONF_last_updated_time == 0 || saved_RIG_CONF_last_updated_time != current_RIG_CONF_last_updated_time )) ; then
			#                       first time ^^^^                             updated ^^
			if (( saved_RIG_CONF_last_updated_time == 0 )); then
				log_line info "Loading rig config $RIG_CONF"
			else
				log_line warning "Rig config $RIG_CONF has been updated, re-loading"
			fi
			# shellcheck disable=SC1090
			source "$RIG_CONF"
			(( saved_RIG_CONF_last_updated_time = current_RIG_CONF_last_updated_time ))

			# forcedly reset the failover mode
			is_failover_connection_in_force_FLAG=0
			API_HOST_URLs_working_collection_index=0

			# parse API_HOST_URLs to API_HOST_URLs_working_collection
			if [[ -n "${API_HOST_URLs-}" ]]; then
				# parse a whole API_HOST_URLs string to the URLs collection array; sanitizing 'https' to 'http' at the same time
				read -t 10 -r -a API_HOST_URLs_working_collection <<< "${API_HOST_URLs//https:\/\//http:\/\/}"
			else
				# HIVE_HOST_URL is deprecated, but better safe than sorry; sanitizing 'https' to 'http' at the same time
				API_HOST_URLs_working_collection[0]="${HIVE_HOST_URL//https:\/\//http:\/\/}"
			fi
			if (( can_haz_bootstrap_servers_FLAG )); then
				# append only unique hosts from API_HOST_URLs_bootstrap_collection
				for (( this_element = 0; this_element < ${#API_HOST_URLs_bootstrap_collection[@]}; this_element++ )); do
					if [[ ! " ${API_HOST_URLs_working_collection[*]} " =~ " ${API_HOST_URLs_bootstrap_collection[this_element]} " ]]; then
						(( this_element_counter++ ))
						API_HOST_URLs_working_collection+=( "${API_HOST_URLs_bootstrap_collection[this_element]}" )
					fi
				done
				log_line info "$this_element_counter bootstrap API servers added"
			fi
			API_HOST_URLs_working_collection_size="${#API_HOST_URLs_working_collection[@]}"
			API_HOST_URL_main="${API_HOST_URLs_working_collection[0]}"
			log_line info "API servers: $( pretty_print_api_hosts "${API_HOST_URLs_working_collection[*]}" "$API_HOST_URLs_working_collection_index" )"

			# export TZ
			[[ -n "$TIMEZONE" ]] && export TZ="$TIMEZONE"
		fi
	else
		log_line warning "Rig config $RIG_CONF not found, waiting..."
		return
	fi

	# WALLET_CONF. load it only at the very start or if updated (considering modification time)
	if [[ -s "$WALLET_CONF" ]] && current_WALLET_CONF_last_updated_time="$( get_file_last_modified_time_in_seconds "$WALLET_CONF" )"; then
		if (( saved_WALLET_CONF_last_updated_time == 0 || saved_WALLET_CONF_last_updated_time != current_WALLET_CONF_last_updated_time )); then
			#                          first time ^^^^                                updated ^^
			if (( saved_WALLET_CONF_last_updated_time == 0 )); then
				log_line info "Loading wallet config $WALLET_CONF"
			else
				log_line warning "Wallet config $WALLET_CONF has been updated, re-loading"
			fi
			# shellcheck disable=SC1090
			source "$WALLET_CONF"
			(( saved_WALLET_CONF_last_updated_time = current_WALLET_CONF_last_updated_time ))
		fi
	else
		log_line warning "Wallet config $WALLET_CONF not found, trying to ignore"
	fi

	# if rig config contains PUSH_INTERVAL then change default to custom
	if [[ -n "${PUSH_INTERVAL-}" ]] && (( PUSH_INTERVAL != push_interval_DEFAULT )); then
		INTERVAL="$PUSH_INTERVAL"
		custom_interval_message="${LGRAY}[push interval ${INTERVAL}s]${NOCOLOR} "
	else
		INTERVAL="$push_interval_DEFAULT"
		custom_interval_message=''
	fi

	# let's send stats even if no FS applied
	if [[ -z "$MINER" || "$MINER" == 'claymore' ]]; then
		MINER='asicminer'
	fi
	if [[ -z "$META" ]]; then
		META='{"asicminer":{"coin":"N/A"}}'
	fi

	log_line info "${custom_interval_message}Collecting stats from ${WHITE}${MINER}${NOCOLOR} API..."

	time_start_collecting_stats="$( get_system_uptime_in_milliseconds )"
	fetch_miner_stats "$MINER"
	time_wasted_collecting_stats_in_s="$( get_time_difference_in_s $(( time_start_collecting_stats )) )"

log_line debug 'process_total_khs_and_arr()'

	process_total_khs_and_arr

	mem="$( get_mem_as_json_array )"
	cpuavg="$( get_loadavg_as_json_array )"
	df="$( get_diskfree_as_string )"
	last_cmd_id="$( get_saved_last_cmd_id )"
#	avg_khs="$( get_avg_khs_as_json )" # averager service is turned out temporarily, as of August 2021

	# construct a request
	request="$(
		jq														\
			--null-input --compact-output						\
			--argjson	rig_id			"${RIG_ID:-null}"		\
			--arg		passwd			"$RIG_PASSWD"			\
			--argjson	last_cmd_id		"${last_cmd_id:-null}"	\
			--arg		miner			"$MINER"				\
			--argjson	meta			"${META:-null}"			\
			--argjson	miner_stats		"${stats:-null}"		\
			--argjson	total_khs		"${total_khs:-null}"	\
			--argjson	avg_khs			"${avg_khs:-null}"		\
			--arg		system_status	"$system_status"		\
			--arg		df				"$df"					\
			--argjson	mem				"${mem:-null}"			\
			--argjson	cpuavg			"${cpuavg:-null}"		\
																\
			'def walk(f):
				. as $in
				| if type == "object" then
					reduce keys_unsorted[] as $key
					( {}; . + { ($key):  ($in[$key] | walk(f)) } ) | f
				elif type == "array" then
					map( walk(f) ) | f
				else
					f
				end;
			{
				"method": "stats", "jsonrpc": "2.0", "id": 0,
				"params": {
					$rig_id, $passwd, $last_cmd_id,
					$miner, $meta,
					$miner_stats, $total_khs, $avg_khs,
					$system_status, $df, $mem, $cpuavg
				}
			} | walk(
					if type == "object" then
						with_entries(select( .value != null and .value != {} and .value != [] ))
					elif type == "array" then
						map(select( . != null and . != {} and .!= [] ))
					else
						.
					end
				)' # remove: 1. empty objects; 2. empty arrays; 3. keys with null value
	)"

	# jq's failover (like in the case of the broken jq or like)
	if [[ $? -ne 0 || -z "$request" ]]; then
		log_line error 'Something went wrong while constructing a JSON request. Engaging a failback mode...'
		debug_print_variable 'RIG_ID' 'last_cmd_id' 'META' 'stats' 'total_khs' 'avg_khs' 'cpuavg'
		# good ol' bash string assembly
		request="{\"method\":\"stats\",\"jsonrpc\":\"2.0\",\"id\":0,\"params\":{\"rig_id\":${RIG_ID},\"passwd\":\"${RIG_PASSWD}\",\"miner\":\"$MINER\",\"system_status\":\"$system_status\"}}"
	fi

	# show the request, password cloaked
	jq '.params.passwd=$cloaked_pass' --arg cloaked_pass "${RIG_PASSWD//?/*}" --compact-output <<< "$request"

	if [[ -z "$RIG_ID" ]]; then
		log_line warning "No RIG_ID, sending stats skipped"
		return
	fi

log_line debug 'check https'

	# !!! and now the duct tape
	# !!! fix /hive/bin/message then ditch this under the bus
	# protection measures -- we don't have https on the vast majority of ASICs
	if [[ "$HIVE_HOST_URL" == 'https://'* ]]; then
		log_line warning "Secure connection to $HIVE_HOST_URL is not supported, most likely"
		if (( ! https_disabled_message_sent_FLAG )); then
			cp "$RIG_CONF" "${RIG_CONF}.original"
			sed -i 's|HIVE_HOST_URL="https://|HIVE_HOST_URL="http://|' "$RIG_CONF"
			message warning "Server URL with HTTPS might not be supported on this ASIC. It's recommended to switch to HTTP (Settings->Mirror select)" --silent
			mv "${RIG_CONF}.original" "$RIG_CONF"
			https_disabled_message_sent_FLAG=1
		fi
	fi

	until (( is_server_push_went_ok_FLAG )); do

log_line debug 'push start'

		if (( is_failover_connection_in_force_FLAG )); then
log_line debug 'failover check'
			# check for a failover mode's age
			set_variable_to_current_system_time_in_seconds 'the_now'
			((
				seconds_passed_since_failover_connection = the_now - time_start_failover_connection,
				seconds_left_till_switch_to_main = failover_connection_duration_in_s_DEFAULT - seconds_passed_since_failover_connection
			))
			if (( seconds_left_till_switch_to_main <= 0 )); then
				# return to the main host
				is_failover_connection_in_force_FLAG=0
				is_api_host_file_relevant_FLAG=0
				API_HOST_URLs_working_collection_index=0
				log_line warning "It's time to switch back to the main API server"
			fi
		fi
log_line debug 'oob check'

		# out of boundaries check
		if (( API_HOST_URLs_working_collection_index >= API_HOST_URLs_working_collection_size )); then
			if (( ! is_failover_connection_in_force_FLAG )); then
				API_HOST_URLs_working_collection_index=0 # use main api host
			else
				API_HOST_URLs_working_collection_index=1
			fi
		fi
log_line debug 'api host check'

		# set working API host
		API_HOST_URL_current="${API_HOST_URLs_working_collection[API_HOST_URLs_working_collection_index]%/}" # cut the trailing slash in host URL, if any (like as in rocketchain's local API server URL)

log_line debug 'whitelabel check'

		# whitelabel's workaround
		if [[ "$API_HOST_URL_main" != *'hiveos.farm'* && "$API_HOST_URL_current" == *'hiveos.farm'* ]]; then
			log_line warning "Whitelabel detected, sending stats to $API_HOST_URL_current skipped..."
			(( API_HOST_URLs_working_collection_index++ )) # iterate to the next host
			continue # start over
		fi

		# calculate and show upstream communication quality
		(( push_total_counter++ ))
		if (( push_bad_counter > 0 )); then
log_line debug 'comm_quality check'
			comm_quality_percentage="$( calculate_quality "$push_bad_counter" "$push_total_counter" )"
			# and here comes some fancy optimization
			(( push_bad_counter < 1000 ))	&& push_bad_counter_humanized="$push_bad_counter"		|| push_bad_counter_humanized="$( humanize "$push_bad_counter" )"
			(( push_total_counter < 1000 ))	&& push_total_counter_humanized="$push_total_counter"	|| push_total_counter_humanized="$( humanize "$push_total_counter" )"
			# finally, then:
			log_line warning "Upstream communication quality ${comm_quality_percentage}% ($push_bad_counter_humanized unsuccessful out of $push_total_counter_humanized)"
		fi

log_line debug 'is_failover_connection_in_force check'

		if (( is_failover_connection_in_force_FLAG )); then
			log_line warning "Failover API server is active, $( seconds2dhms "$seconds_left_till_switch_to_main" ) till returning to main"
			log_line info "API servers: $( pretty_print_api_hosts "${API_HOST_URLs_working_collection[*]}" "$API_HOST_URLs_working_collection_index" )"
		fi

		log_line info "Sending stats (${#request} bytes) to ${API_HOST_URL_current}..."

		request_endpoint="${API_HOST_URL_current}/worker/api?id_rig=${RIG_ID}&method=stats"
		time_start_sending_stats="$( get_system_uptime_in_milliseconds )"
		response="$(
			curl												\
																\
				--insecure --location --data @- --silent		\
																\
				--header 'Content-Type: application/json'		\
				--request POST "$request_endpoint"				\
																\
				--connect-timeout "$curl_connect_timeout"		\
				--max-time "$curl_max_time"						\
																\
				--verbose										\
				--trace-time									\
				--fail											\
																\
			<<< "$request" 2> "$latest_curl_log"
		)"
		curl_exitcode=$?
		time_wasted_sending_stats_in_s="$( get_time_difference_in_s $(( time_start_sending_stats )) )"
log_line debug 'curl exit'

		if (( curl_exitcode == 0 )); then
			is_server_push_went_ok_FLAG=1
			# a one-time write if connection was successful (or the file does not exist)
			if (( ! is_api_host_file_relevant_FLAG )) || [[ ! -s "$API_HOST_FILE" ]]; then
				if echo "HIVE_HOST_URL=\"$API_HOST_URL_current\"" > "$API_HOST_FILE"; then
					is_api_host_file_relevant_FLAG=1
				fi
			fi
		else
			(( push_bad_counter++ ))
			is_api_host_file_relevant_FLAG=0

			log_line error "Error sending stats with exitcode $curl_exitcode in ${WHITE}${time_wasted_sending_stats_in_s}s${NOCOLOR}. Connection log:"

			if [[ -s "$latest_curl_log" ]]; then
				# pretty-print the log with indentation
				readarray -t latest_curl_log_as_array < "$latest_curl_log"
				printf '%b' "${DGRAY-}"
				#       yyyy-mm-dd
				printf '           %s\n' "${latest_curl_log_as_array[@]}"
				printf '%b' "${NOCOLOR-}"
			fi

			if (( API_HOST_URLs_working_collection_index == 0 )); then
				set_variable_to_current_system_time_in_seconds 'time_start_failover_connection'
				is_failover_connection_in_force_FLAG=1
				log_line warning 'Main API server is not available, switching to the failover one'
			else
				log_line warning 'This failover API server is not available, switching to the next one'
			fi
			(( API_HOST_URLs_working_collection_index++ )) # iterate to the next host

			sleep_with_progress_bar $(( INTERVAL / 2 )) # a kind of brother's mercy to the network and local router
		fi
	done

#	if [[ $curl_exitcode -ne 0 || -z "$response" ]]; then
#		log_line error "No luck. Let's refresh the IP cache..."
#		/hive/bin/timeout -t 10 /hive/bin/cache-hive-ip
#		return "$curl_exitcode"
#	fi

	# errors processing
	local error
	#
	if ! error="$( jq --raw-output '.error' <<< "$response" )"; then
		log_line error "Invalid response received in ${WHITE}${time_wasted_sending_stats_in_s}s${NOCOLOR}:\n$response"
		return 1
	fi

	if is_JSON_string_not_empty_or_null "$error"; then
		log_line error "Error response received in ${WHITE}${time_wasted_sending_stats_in_s}s${NOCOLOR}: $error"
		return 1
	fi


	# command processing
	local command
	#
	command="$( jq --raw-output '.result.command' <<< "$response" )"
	if [[ "$command" == 'OK' ]]; then
		if [[ -f "$last_cmd_id_FILE" ]]; then
			(( script_DEBUG )) && log_line debug "[DEBUG] removing $last_cmd_id_FILE"
			rm "$last_cmd_id_FILE"
		fi
	else
		local response_stripped="${response//\\n/\\\\n}" # neuter the \n's
		log_line info "Server answer: $( jq --compact-output --color-output '.result' <<< "$response_stripped" )"
		skip_the_sleep_FLAG=1
	fi


	# confseq processing
	local confseq_received confseq_saved
	#
	confseq_received="$( jq --raw-output '.result.confseq' <<< "$response" )"
	if is_JSON_string_not_empty_or_null "$confseq_received"; then
		if [[ -s "$confseq_FILE" ]]; then
			confseq_saved="$( < "$confseq_FILE" )"
		else
			# first time run, just save current confseq
			confseq_saved="$confseq_received"
			echo "$confseq_received" > "$confseq_FILE"
		fi

		if (( confseq_saved != confseq_received )); then
			# save updated confseq
			echo "$confseq_received" > "$confseq_FILE"
			case "$command" in
				'config' | 'wallet' | 'asic_oc' | 'asic' )
					log_line debug "[DEBUG] config command received. Config sequence updated: $confseq_saved -> $confseq_received"
				;;
				*)
					log_line debug "[DEBUG] no config command received, but config sequence updated: $confseq_saved -> $confseq_received. Let's say hello again..." # (and then get an updated config)
					hello # TODO fork to bg?
				;;
			esac
		fi
	else
		(( script_DEBUG )) && log_line debug "[DEBUG] server answer lacks 'confseq' key, confseq processing skipped"
	fi


	# to batch or not to batch
	local body
	local -i commands_count this_command_index
	#
	if [[ "$command" != 'batch' ]]; then
		body="$( jq --compact-output '.result' <<< "$response" )"
		do_command
	else
		commands_count="$( jq '.result.commands | length' <<< "$response" )"
		log_line info "Got $commands_count batch commands"
		for (( this_command_index = 0; this_command_index < commands_count; this_command_index++ )); do
			body="$( jq --compact-output --argjson index "$this_command_index" '.result.commands[$index]' <<< "$response" )"
			command="$( jq --raw-output '.command' <<< "$body" )" # get command for batch
			do_command
		done
	fi
}

function decloak_string {
	#
	# a way to render all this escape-golfing to a plain text
	#

	# args
	local -r string_to_decloak="${1-}"

	# vars
	local string_with_blanks_deduplicated string_unescaped

	# asserts
	[[ -n "$string_to_decloak" ]] || return 0 # empty is ok

	# code
	printf -v string_unescaped '%b' "$string_to_decloak"  # 1. render ESCapes
	string_with_blanks_deduplicated="${string_unescaped//+([[:blank:]])/ }" # 2. compress blanks
	echo "$string_with_blanks_deduplicated"
}

shopt -s extglob # this is needed for the bash parser to properly parse a code block (function is also a code block) that contains any extglob syntax
function is_allowed_cmd {
	# args
	local cmd_to_test="${1-}"

	# vars
	local reason_message='undefined' cmd_to_test_decloaked

	# flags
	local -i reason_index=1

	# asserts
	[[ -n "$cmd_to_test" ]] || return 0 # empty is ok

	# code
	shopt -s extglob

	cmd_to_test_decloaked="$( decloak_string "$cmd_to_test" )"
	case "$cmd_to_test_decloaked" in
		!(*.)'sh '*)
			reason_index=1
			reason_message='Illegal execution of shell'
		;;

		*'|'?( )?(ba|da|a)'sh'*)
			reason_index=2
			reason_message='Illegal pipe to shell'
		;;

		*'chmod'* | *'curl'* | *'wget'* | *'source'* | *'dropbear'* | *'perl'* | *'nc '*)
			reason_index=3
			reason_message='Illegal command'
		;;

		*'$'*)
			reason_index=4
			reason_message='Illegal $VAR use'
		;;

		'')
			reason_index=0
			reason_message='Ok (empty)'
		;;

		*)
			reason_index=0
			reason_message='Ok'
		;;
	esac
	shopt -u extglob

	echo "$reason_message"
	return $(( reason_index ))
}
shopt -u extglob # turn it off, as in the default state

function do_command {
	# consts
	local -r command_log="/tmp/${script_basename}-${command// /-}.log"

	# vars
	local cmd_id client_version asic_oc firmware_url
	local config justwrite line NEW_PASSWD request response error wallet
	local request_endpoint
	local -i curl_exitcode
	#local TMUX	# let's test it later

	# code
#	[[ -z "$command" ]] && command="$( jq --raw-output '.command' <<< "$body" )" #get command for batch

	# cmd_id processing (optional command identifier)
	cmd_id="$( jq --raw-output '.id' <<< "$body" )"
	is_JSON_string_empty_or_null "$cmd_id" && cmd_id=''
	# save last cmd_id
	(( script_DEBUG )) && log_line debug "[DEBUG] incoming cmd_id is '$cmd_id'"
	if (( cmd_id > 0 )); then
		(( script_DEBUG )) && log_line debug "[DEBUG] saving cmd_id '$cmd_id' to $last_cmd_id_FILE"
		echo "$cmd_id" > "$last_cmd_id_FILE"
	fi

	log_line ok "'$command' received in ${WHITE}${time_wasted_sending_stats_in_s}s"

	# consult a blacklist
	if [[ "$ASIC_MODEL" == 'Avalon'* ]]; then
		forbidden_commands_RE='^(asic|exec|firmware-upgrade)$'
		if [[ "$command" =~ $forbidden_commands_RE ]]; then
			log_line warning "'$command' is forbidden for this firmware"
			message warning "Command '$command' is forbidden for this firmware" --id="$cmd_id" --silent
			return
		fi
	fi

	case "$command" in
		'OK')
			# do nothing
			:
		;;

		'reboot')
			message ok 'Rebooting' --id="$cmd_id" --silent
			log_line ok 'Rebooting'
			/sbin/reboot
		;;

		'upgrade')
			client_version="$( jq --raw-output '.version' <<< "$body" )"
			is_JSON_string_empty_or_null "$client_version" && client_version=''
			screen -dm -S selfupgrade bash -c '
				selfupgrade '"$client_version"' |& tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Client update successful" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Client update failed" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'upgrade beta')
			screen -dm -S selfupgrade bash -c '
				selfupgrade master |& tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Client update successful" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Client update failed" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'exec')
			local exec_command shutdown_fuse_file

			exec_command="$( jq --raw-output '.exec' <<< "$body" )"

			# let's inform the user that the command is received
			#message default "$exec_command (running, id: $cmd_id)" --id="$cmd_id" --verbose

			case "$exec_command" in
				'hssh start' | 'hssh start debug' | 'hssh restart' | 'hssh stop')
					unset TMUX # !!! a duct tape for HSSH to start
				;;
				'sreboot shutdown')
					shutdown_fuse_file="/tmp/${script_basename}-shutdown-fuse.lock"
					if [[ ! -f "$shutdown_fuse_file" ]]; then
						message warning 'Vast majority of ASICs does not support shutdown. Click for details' --payload --id="$cmd_id" --silent <<-EOF
							<h3>Vast majority of ASICs does not support shutdown</h3>It might be the ASIC will simply go offline. You will more than likely have to power it off manually.
							If you know what are you doing, please <strong>send this command one more time</strong>
							EOF
						touch "$shutdown_fuse_file"
						return
					else
						rm "$shutdown_fuse_file"
						message ok 'ASIC powered off' --id="$cmd_id" --silent
						snore 5 # wait 5s until the message has been sent
					fi
				;;
				*)
					# TMP F-words blocklist
					test_message="$( is_allowed_cmd "$exec_command" )"; test_code=$?
					if (( test_code > 0 )); then
						log_line warning "$test_message. A potentially malicious command received, let's do nothing"
						message error "$exec_command (failed, exitcode $(( 255 + test_code )))" --escape-templates --id="$cmd_id" --silent
						return
					fi
				;;
			esac

			local -i exec_time_limit=0
			local exec_timeout timeout_app=''
			local exec_screen_name="exec-${cmd_id}-screen"
			local exec_log="/tmp/${exec_screen_name}.log"
			local exec_accessory_script="/run/hive/${exec_screen_name}.sh"

			if [[ "${exec_command:0:2}" == ':;' || "$exec_command" == 'hssh start' ]]; then
				# !!! a secret spell: if the command to exec is prefixed with ':;', then no time limit will be imposed
				# !!! also no timeout for HSSH
				:
			else
				(( exec_time_limit = 60 * 60 * 3 )) # 3 hrs tops
				# shellcheck disable=SC2076
				if [[ "$ASIC_MODEL" == 'Zig Z1' || "$ASIC_MODEL" == 'Zig Z1+' || "$ASIC_MODEL" == 'Toddminer C1'* ]]; then
					# use Debian /usr/bin/timeout
					timeout_app='timeout'
				else
					# use a BusyBox one OR our own
					timeout_app='timeout -t'
				fi
			fi

			# a new way thru the gnu screen
			if touch "$exec_accessory_script" && touch "$exec_log"; then
				# generate a temporary script
				# shellcheck disable=SC2016
				echo '#!/hive/sbin/bash
					# args
					declare -r exec_command="$1"
					declare -r exec_log="$2"
					declare -r cmd_id="$3"
					declare -r timeout_app="$4"
					declare -r exec_time_limit="$5"

					# vars
					declare -i exec_exitcode

					# code
					echo "# $exec_command"
					echo
					if (( exec_time_limit == 0 )); then
						$exec_command 0<&- |& tee "$exec_log"
					else
						$timeout_app "$exec_time_limit" bash -c "$exec_command" 0<&- |& tee "$exec_log"
					fi
					exec_exitcode="${PIPESTATUS[0]}"
					case "$exec_exitcode" in
						0)		message info "$exec_command" --escape-templates --id="$cmd_id" --silent --payload < "$exec_log"													;;
						127)	message error "$exec_command (command not found? exitcode $exec_exitcode)" --escape-templates --id="$cmd_id" --silent --payload < "$exec_log"	;;
						*)		message error "$exec_command (failed, exitcode $exec_exitcode)" --escape-templates --id="$cmd_id" --silent --payload < "$exec_log"				;;
					esac
					rm "$0" "$exec_log"
				' > "$exec_accessory_script"

				# run this temporary script in a screen
				chmod +x "$exec_accessory_script"
				screen -dm -S "$exec_screen_name" "$exec_accessory_script" "$exec_command" "$exec_log" "$cmd_id" "$timeout_app" "$exec_time_limit"
			else
				# better be safe than sorry
				# execute a command in a such way just in the case of a read-only fs or anything weird
				# here's a file-less approach thru pipe:
				if (( exec_time_limit == 0 )); then
					exec_timeout='bash -c' # no time limit at all
				else
					exec_timeout="$timeout_app $exec_time_limit bash -c"
				fi

				# shellcheck disable=SC2016
				$exec_timeout '
					exec_output=$( '"$exec_command"' )
					exec_exitcode="$?"
					if (( exec_exitcode == 0 )); then
						echo "$exec_output" | message info "$0" --escape-templates --id="$1" --silent --payload
					else
						echo "$exec_output" | message error "$0 (failed, exitcode $exec_exitcode)" --escape-templates --id="$1" --silent --payload
					fi
				' "$exec_command" "$cmd_id" & disown
			fi
		;;

		'asic_oc')
			if is_screen_session_exist "$command"; then
				screen_session_terminate "$command"
				log_line warning "Command '$command' already running. Terminated."
				snore 5
			fi
			export asic_oc="$( jq --raw-output '.asic_oc' <<< "$body" )"
			[[ -f /config/use-new-asic-oc ]] && mv /config/use-new-asic-oc /hive-config/use-new-asic-oc # adjusting legacy location to an actual one

			# choose the right OC script
			local -i use_new_asic_oc_FLAG=0 # default to old
			if [[ "$ASIC_MODEL" == 'Antminer L3+'* || "$ASIC_MODEL" == 'Antminer S9'* || "$ASIC_MODEL" == 'Antminer T9+'* || "$ASIC_MODEL" == 'Antminer S10'* ]] && is_version "$ASIC_CUSTOM_FW_VERSION" '>=' '1.02'; then
				use_new_asic_oc_FLAG=1
			elif [[ "$ASIC_MODEL" == 'Avalon'* ]]; then
				use_new_asic_oc_FLAG=1
			elif is_version "$ASIC_CUSTOM_FW_VERSION" '>=' '2.0'; then
				# that means Series 17 version range atm
				use_new_asic_oc_FLAG=1
			elif [[ "$ASIC_MODEL" == 'Antminer S19'* || "$ASIC_MODEL" == 'Antminer T19'* ]]; then
				use_new_asic_oc_FLAG=1
			elif [[ -f /hive-config/use-new-asic-oc ]]; then
				#      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ here comes a secret feature: forced new OC script for any model
				use_new_asic_oc_FLAG=1
			fi

			if (( use_new_asic_oc_FLAG )); then
				asic_oc_cmd='asic-oc'
			else
				asic_oc_cmd='asic_oc' # almost deprecated script, left for compatibility with legacy FW
			fi

			screen -dm -S "$command" bash -c '
				echo "Auto-tune parameters:"
				echo
				jq "." <<< "$asic_oc"
				echo
				'"$asic_oc_cmd"' "$asic_oc" |& tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Auto-tune is finished. Click for details" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Auto-tune error. Click for details" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'firmware-upgrade')
			if is_screen_session_exist "$command"; then
				log_line warning "Command '$command' already running. Execution skipped."
				message warning "Firmware upgrade skipped. Click for details" --payload --id="$cmd_id" --silent <<< "Previous firmware upgrade process is still running. Please wait for it to finish and then send the command again."
				return
			fi
			export firmware_url="$( jq --raw-output '.firmware_url' <<< "$body" )"
			screen -dm -S "$command" bash -c '
				firmware-upgrade "$firmware_url" |& tee '"$command_log"'
				if (( PIPESTATUS[0] == 0 )); then
					message ok "Firmware upgrade successful, rebooting..." --payload --id='"$cmd_id"' --silent < '"$command_log"'
				else
					message error "Firmware upgrade failed" --payload --id='"$cmd_id"' --silent < '"$command_log"'
				fi
			'
		;;

		'config')
			config="$( jq --raw-output '.config' <<< "$body" )"
			justwrite="$( jq --raw-output '.justwrite' <<< "$body" )" #don't restart miner, just write config, maybe WD settings will be updated
			if is_JSON_string_not_empty_or_null "$config"; then
				#scan for a password change
				while read -t 10 -r line; do
					if [[ "$line" =~ ^RIG_PASSWD=\"(.+)\" ]]; then
						NEW_PASSWD="${BASH_REMATCH[1]}"
						break
					fi
				done <<< "$config"

				# Password change ---------------------------------------------------
				if [[ "$RIG_PASSWD" != "$NEW_PASSWD" ]]; then
					log_line warning "Old password: $RIG_PASSWD, new password: $NEW_PASSWD"

					message warning 'New password received, please wait...' --id="$cmd_id" --silent
					request="$( jq --null-input --compact-output \
						--arg rig_id "$RIG_ID" --arg passwd "$RIG_PASSWD" \
						'{ "method": "password_change_received", "params": {$rig_id, $passwd}, "jsonrpc": "2.0", "id": 0}'
					)"
					request_endpoint="${API_HOST_URL_current}/worker/api?id_rig=${RIG_ID}&method=password_change_received"
					response="$(
						curl												\
																			\
							--insecure --location --data @- --silent		\
																			\
							--header 'Content-Type: application/json'		\
							--request POST "$request_endpoint"				\
																			\
							--connect-timeout "$curl_connect_timeout"		\
							--max-time "$curl_max_time"						\
																			\
						<<< "$request"
					)"

					curl_exitcode=$?
					if (( curl_exitcode != 0 )); then
						log_line error 'Error notifying the server about "password_change_received"'
						message error 'Error notifying the server about "password_change_received"' --id="$cmd_id" --silent
						return "$curl_exitcode" #better exit because password will not be changed
					fi

					error="$( jq --raw-output '.error' <<< "$response" )"
					if is_JSON_string_not_empty_or_null "$error"; then
						log_line error "Server error: $( jq --raw-output '.error.message' <<< "$response" )"
						return 1
					fi

					jq '.' <<< "$response"
					#after this there will be new password on server, so all new request should use new one
				fi

				# Write new config and load it ---------------------------------------
				echo "$config" > "$RIG_CONF" && sync
				# shellcheck disable=SC1090
				source "$RIG_CONF"

				# Save wallet if given -----------------------------------------------
				if wallet="$( jq --raw-output '.wallet' <<< "$body" )" && is_JSON_string_not_empty_or_null "$wallet"; then
					echo "$wallet" > "$WALLET_CONF" && sync
				fi

				# Final actions ---------------------------------------------------------
				if (( "${justwrite:-0}" == 1 )); then
					message ok 'Rig config changed' --id="$cmd_id" --silent
				else
					if /hive/bin/miner restart; then
						message ok 'Rig config changed, miner restarted' --id="$cmd_id" --silent
					else
						message warning 'Rig config changed, but miner restarted with error' --id="$cmd_id" --silent
					fi
					echo
				fi

				# Start Hashrate Watchdog. It will exit if WD_ENABLED=0 ---------------------------
				if (( "${WD_ENABLED:-0}" )); then
					nohup wd stop &> /dev/null
					snore 5
				fi
				wd start &
			else
				message error 'No rig "config" given' --id="$cmd_id" --silent
			fi
		;;

		'wallet')
			if wallet="$( jq --raw-output '.wallet' <<< "$body" )" && is_JSON_string_not_empty_or_null "$wallet"; then
				echo "$wallet" > "$WALLET_CONF" && sync

				if /hive/bin/miner restart; then
					message ok 'Wallet changed, miner restarted' --id="$cmd_id" --silent
				else
					message warning 'Wallet changed, but miner restarted with error' --id="$cmd_id" --silent
				fi
				echo
			else
				message error 'No "wallet" config given' --id="$cmd_id" --silent
			fi
		;;

		'asic')
			hiveon_config="$( jq --raw-output '.asic' <<< "$body" )"
			if is_JSON_string_not_empty_or_null "$hiveon_config"; then
				grep -v '^_' <<< "$hiveon_config" > "$HIVEON_CONF"
				grep -v '^_' <<< "$hiveon_config" > "$ASIC_CONF"
				volt_conf="$( ant-functions.sh 'generate_volt_conf' <<< "$hiveon_config" )"
				[[ -n "$volt_conf" ]] && echo "$volt_conf" > "$HIVEON_CONF_VOLT"
				sync
				if /hive/bin/miner restart; then
					message ok 'ASIC config changed, miner restarted' --id="$cmd_id" --silent
				else
					message warning 'Error restarting miner' --id="$cmd_id" --silent
				fi
			else
				message error 'No "asic" config given' --id="$cmd_id" --silent
			fi
		;;

		'')
			# a kinda trap for the backend glitches
			if [[ -n "$response" ]]; then
				message warning "Empty command received from server" --payload --id="$cmd_id" --silent < <( jq '.' <<< "$response" )
			else
				message warning "Empty response received from server" --id="$cmd_id" --silent
			fi
			log_line error "Empty command received"
		;;

		*)
			if [[ -n "$body" ]]; then
				message warning "Unknown command '$command' received from server" --payload --id="$cmd_id" --silent < <( jq '.' <<< "$body" )
			else
				message warning "Unknown command '$command' received from server" --id="$cmd_id" --silent
			fi
			log_line error "Unknown command received: '$command'"
		;;

	esac
}

function sleep_with_progress_bar {
	#
	# print a shrinking progress bar while sleeping
	#
	# Usage: sleep_with_progress_bar 'seconds_to_sleep'
	#

	# args
	local -r -i seconds_to_sleep="$1"

	# vars
	local -i this_step
	local seconds_remaining_as_spaces seconds_remaining_as_dots

	# code

	for (( this_step = 0; this_step < seconds_to_sleep; this_step++ )); do
		printf -v seconds_remaining_as_spaces '%*s' $(( seconds_to_sleep - this_step ))
		seconds_remaining_as_dots="${seconds_remaining_as_spaces// /.}"
		printf '\r%b%s%b%*s\r' "${DGRAY}" "$seconds_remaining_as_dots" "${NOCOLOR}" "$this_step"
		snore 1
	done
	printf '\r%*s\n' "$seconds_to_sleep" # clear the line and then \n
}

function round_div_x100 {
	#
	# A simple integer division with round (https://stackoverflow.com/a/59414940/12559612)
	# virtual decimal dot, nn.nn precision
	#
	# Usage: round_div_x100 'item' 'total'
	#
	# Example: round_div_x100 4 28 -> 1429 (actually 14.29)
	#

	# args
	local -r -i item="${1-}"
	local -r -i total="${2-}"

	# consts
	local -r -i item_x10000=$(( item * 10000 )) # 100.00

	# code
	echo $(( 2 * item_x10000 / total - item_x10000 / total ))
}

function calculate_quality {
	#
	# calculate a quality in percent from 'bad' and 'total' counters
	# result in fake decimal-points: nn.nn
	#
	# Usage: calculate_quality 'bad_counter' 'total_counter'
	#

	# args
	local -r -i bad_counter="${1-}"
	local -r -i total_counter="${2-}"

	# vars
	local -i bad_percentage_x100 quality_percentage_x100
	local quality_percentage_fake_decimal

	# code
	bad_percentage_x100="$( round_div_x100 "$bad_counter" "$total_counter" )"
	(( quality_percentage_x100 = 100000 - bad_percentage_x100*10 )) # 100% - x
	quality_percentage_fake_decimal="$( milliseconds_to_seconds "$quality_percentage_x100" )" # (int)7799 -> (string)77.99 (in fact, those milliseconds are centiseconds)

	echo "$quality_percentage_fake_decimal"
}

function internal_watchdog {
	# traps
	#trap -- 'log_line debug "internal watchdog ${PPID}:${$}:${BASHPID} killed"' EXIT

	# args
	local -r -i timeout_in_s="${1-120}" # default is 2 minutes

	# vars
	local watchdog_id

	# cod
	watchdog_id="${PPID}:${$}:${BASHPID}"
	log_line debug "internal watchdog $watchdog_id starting now, timeout is ${timeout_in_s}s"
	snore "$timeout_in_s" # a pause to let the parent terminate this watchdog instance calmly

	if (( is_pstree_supported_FLAG )); then
		log_line error "internal watchdog $watchdog_id engadeg. BARK-BARK, time is out! Here's the process tree:"
		echo
		pstree -p "$PPID"
		echo
	else
		log_line error "internal watchdog $watchdog_id engadeg. BARK-BARK, time is out!"
	fi

	# check for hanging external commands
	# shellcheck disable=SC2034
	# bc it's by ref
	local -A procfs_STRUCT=()
	local -i this_pid
	local this_comm this_state this_ppid this_cmdline
	if populate_procfs_struct 'procfs_STRUCT' 0; then
		for this_pid in $( get_children_pids_of "$$" 'procfs_STRUCT' ); do
			#                                    ^^ my proc group
			#   ...and not me vvvvvvv
			if (( this_pid != BASHPID )); then
				# here's my sweet uterine sibling, let's slaugher it
				{
					this_ppid="$( get_pid_attribute "$this_pid" 'ppid' 'procfs_STRUCT' )"
					this_comm="$( get_pid_attribute "$this_pid" 'comm' 'procfs_STRUCT' )"
					this_state="$( get_pid_attribute "$this_pid" 'state' 'procfs_STRUCT' )"
					this_cmdline="$( get_pid_cmdline_from_procfs "$this_pid" )"
					if [[ "$this_state" != 'Z' ]]; then
						# not a zombie
						log_line debug "internal watchdog $watchdog_id: ${this_comm}[${this_state}]${this_cmdline} (PPID $this_ppid, PID $this_pid) hanging, sending SIGTERM"
						if kill -0 "$this_pid" 2> /dev/null; then
							# be nice, post SIGTERM first
							kill -s SIGTERM "$this_pid"
							snore 1
							if kill -0 "$this_pid" 2> /dev/null; then
								log_line debug "internal watchdog $watchdog_id: PID $this_pid is bulletproof, eh? okay, shooting SIGKILL"
								kill -s SIGKILL "$this_pid"
							fi
						fi
					else
						# a zombie!
						log_line debug "internal watchdog $watchdog_id: ${this_comm}[${this_state}]${this_cmdline} (PPID $this_ppid, PID $this_pid) goes zombie, sending SIGCHLD to $this_ppid"
						kill -s SIGCHLD "$this_ppid" # to the parent
						snore 10 # wait for the parent to put the zombie to rest (and then to kill the watchdog)
						if kill -0 "$this_pid" 2> /dev/null; then
							log_line debug "internal watchdog $watchdog_id: PID $this_pid is bulletproof, eh? okay, let's kill the whole agent"
							kill -s SIGKILL "$this_ppid"
						fi
					fi
				} & # let's parallel it all
			fi
		done
	else
		log_line error 'Something wrong with /procfs'
	fi

	snore "$timeout_in_s" # pause again to let the parent terminate this watchdog instance calmly
	log_line error "internal watchdog $watchdog_id: Why I still am alive? Sending SIGUSR1 to my parent, PID $$"
	kill -s SIGUSR1 "$$"
	log_line error "internal watchdog $watchdog_id: Why I still am alive? Sending SIGCHLD to my parent, PID $$"
	kill -s SIGCHLD "$$"

	log_line debug "internal watchdog $watchdog_id: Really?! Looks like some the agent's malfunction--you should never see this message"
	jobs -l
	top -b -n1 | grep -vE '[0-9] \['
}


# global traps

trap -- 'log_line debug "SIGHUP received, ignoring..."' SIGHUP
#trap -- 'log_line debug  "\n\nAborting...\n\n"; snore 5' EXIT # !!! never this goes to production ever
trap -- 'log_line debug "SIGUSR1 received, executing an unconditional return()"; return' SIGUSR1


# global consts

# paths to conf files
# TODO move to /hive/etc/environment
declare -r RIG_CONF='/hive-config/rig.conf'
declare -r WALLET_CONF='/hive-config/wallet.conf'
declare -r HIVEON_CONF='/hive-config/hiveon.conf'
declare -r HIVEON_CONF_VOLT='/config/manual_freqs.txt'
declare -r ASIC_CONF='/config/config.conf'
# paths to runtime vars
declare -r API_HOST_FILE='/run/hive/api_host_url' # an accessory file for the /hive/bin/message and /hive/bin/hello
declare -r total_khs_FILE='/run/hive/khs'
declare -r avg_khs_FILE='/run/hive/khs_avg' # Averages in JSON format
declare -r arr_FILE='/run/hive/arr' # Accepted/Rejected ratio * 100
declare -r last_cmd_id_FILE='/run/hive/last_cmd_id'
declare -r confseq_FILE='/run/hive/confseq'
declare -r latest_curl_log="/run/hive/${script_basename}-curl.log"  # looks like /tmp on a few models (at least on S9 hiveon) is on top of NAND -- let's wear it less
#
declare -r miner_API_host='localhost' # TODO rename 'miner' to 'cgminer'
declare -r -i miner_API_port=4028
#
declare -r -i failover_connection_duration_in_m_DEFAULT=10
declare -r -i failover_connection_duration_in_s_DEFAULT=$(( failover_connection_duration_in_m_DEFAULT * 60 ))
declare -r -i push_interval_DEFAULT=10
#
declare -r -i curl_connect_timeout=15 curl_max_time=25


# global arrays

declare -a API_HOST_URLs_working_collection=()
declare -a API_HOST_URLs_bootstrap_collection=(
	# ??? should move it to /hive/etc/environment
	'http://helsinki.hiveos.farm'
	'http://msk.hiveos.farm'
	'http://paris.hiveos.farm'
	'http://amster.hiveos.farm'
	'http://ca1.hiveos.farm'
	'http://api-ru-cf.hiveos.farm'
	'http://ap.hiveos.farm'
	'http://naw.hiveos.farm'
	'http://api2msk.hiveos.farm'
	'http://api.hiveos.farm'
)


# global vars

declare MINER='asicminer'
declare total_khs system_status stats
declare -i INTERVAL=push_interval_DEFAULT
declare -i time_wasted_general time_remaining_general
declare -i push_total_counter=0 push_bad_counter=0
#
declare -i time_start_failover_connection=0 seconds_passed_since_failover_connection=0 seconds_left_till_switch_to_main=0
declare -i API_HOST_URLs_working_collection_index=0
declare -i API_HOST_URLs_working_collection_size=0
declare API_HOST_URL_current API_HOST_URL_main
#
declare -i saved_RIG_CONF_last_updated_time=0 saved_WALLET_CONF_last_updated_time=0
declare -i internal_watchdog_time_limit


# global flags

declare -i https_disabled_message_sent_FLAG=0
declare -i skip_the_sleep_FLAG=0
declare -i is_failover_connection_in_force_FLAG=0
declare -i is_api_host_file_relevant_FLAG=0
declare -i can_haz_bootstrap_servers_FLAG=1 # let's act willfully
declare -i is_pstree_supported_FLAG=0


# sources

# shellcheck disable=SC1091
{
	[[ -t 1 ]] && source /hive/bin/colors
	source /hive/bin/asic-model
	source /hive/bin/hive-functions.sh || { echo 'ERROR: /hive/bin/hive-functions.sh not found'; exit 1; }
}


# main

#$PPID - might be parent screen pid
screen_count="$( screen -ls | grep "\.agent" | grep -Fcv "$PPID" )"

#there will be still 1 process for subshell
#[[ `ps aux | grep "./agent" | grep -vE "grep|screen|SCREEN|$$" | wc -l` -gt 1 ]] &&
if (( screen_count > 0 )); then
	echo -e "${RED}Agent screen is already running${NOCOLOR}"
	echo -e "Run ${CYAN}agent-screen${NOCOLOR} to resume screen"
	exit 1
fi

log_line ok "$script_mission, version $script_version started"
log_line info "Detected ASIC model: ${WHITE}$ASIC_MODEL"
echo

# (re)starting wd
if (( "${WD_ENABLED:-0}" )); then
	nohup wd stop &> /dev/null
	snore 5
fi
wd start &

# set a flag for the process management
pstree -p "$$" &> /dev/null	&& is_pstree_supported_FLAG=1

# main infinite loop

(( internal_watchdog_time_limit = curl_connect_timeout * ( ${#API_HOST_URLs_bootstrap_collection[@]} + 3 ) ))

while true; do
	SECONDS=0
	skip_the_sleep_FLAG=0

	internal_watchdog "$internal_watchdog_time_limit" 0<&- & disown # start the local watchdog with 1m timeout
	internal_watchdog_PID="$!"

	fetch_stats_and_push_them_to_server

#	log_line debug "killing watchdog #$internal_watchdog_PID"
	kill "$internal_watchdog_PID" || log_line debug "cannot kill watchdog #${internal_watchdog_PID}?"

	if (( skip_the_sleep_FLAG )); then
		# no interval to make the agent more responsive and instantly push last_cmd_id to the server
		echo
		(( script_DEBUG )) && log_line warning '[DEBUG] skip the nap to improve responsiveness after receiving a command'
	else
		(( time_wasted_general = SECONDS ))
		(( time_remaining_general = INTERVAL - time_wasted_general ))

		(( time_remaining_general < 0 )) && log_line warning "Stats gathering/sending cycle took ${time_wasted_general}s, overtime is ${time_remaining_general/-}s"

		sleep_with_progress_bar "$INTERVAL"
	fi
done

exit 1 # and quote the raven: "nevermore!"
